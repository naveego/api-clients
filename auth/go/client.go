// Package  implements the Azure ARM  service API version 3.13.0.
//
// Service for authenticating to the Naveego platorm
package

// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
    "context"
    "github.com/Azure/go-autorest/autorest"
    "github.com/Azure/go-autorest/autorest/azure"
    "github.com/Azure/go-autorest/autorest/validation"
    "github.com/Azure/go-autorest/tracing"
    "net/http"
)

const (
// DefaultBaseURI is the default URI used for the service
DefaultBaseURI = "")

// BaseClient is the base client for .
type BaseClient struct {
    autorest.Client
    BaseURI string
}

// New creates an instance of the BaseClient client.
func New()BaseClient {
    return NewWithBaseURI(DefaultBaseURI, )
}

// NewWithBaseURI creates an instance of the BaseClient client.
func NewWithBaseURI(baseURI string, ) BaseClient {
    return BaseClient{
        Client: autorest.NewClientWithUserAgent(UserAgent()),
        BaseURI: baseURI,
    }
}

    // AuthorizeMethod sends the authorize request.
    func (client BaseClient) AuthorizeMethod(ctx context.Context) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.AuthorizeMethod")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.AuthorizeMethodPreparer(ctx)
        if err != nil {
        err = autorest.NewErrorWithError(err, ".BaseClient", "AuthorizeMethod", nil , "Failure preparing request")
        return
        }

                resp, err := client.AuthorizeMethodSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, ".BaseClient", "AuthorizeMethod", resp, "Failure sending request")
                return
                }

                result, err = client.AuthorizeMethodResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, ".BaseClient", "AuthorizeMethod", resp, "Failure responding to request")
                }

        return
        }

        // AuthorizeMethodPreparer prepares the AuthorizeMethod request.
        func (client BaseClient) AuthorizeMethodPreparer(ctx context.Context) (*http.Request, error) {
            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/oauth2/authorize"))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // AuthorizeMethodSender sends the AuthorizeMethod request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) AuthorizeMethodSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // AuthorizeMethodResponder handles the response to the AuthorizeMethod request. The method always
    // closes the http.Response Body.
    func (client BaseClient) AuthorizeMethodResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusFound),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // CreateMethod sends the create request.
    func (client BaseClient) CreateMethod(ctx context.Context, body UserCreateUserType) (result UserUserType, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.CreateMethod")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                if err := validation.Validate([]validation.Validation{
                { TargetValue: body,
                 Constraints: []validation.Constraint{	{Target: "body.User", Name: validation.Null, Rule: true, Chain: nil }}}}); err != nil {
                return result, validation.NewError(".BaseClient", "CreateMethod", err.Error())
                }

                    req, err := client.CreateMethodPreparer(ctx, body)
        if err != nil {
        err = autorest.NewErrorWithError(err, ".BaseClient", "CreateMethod", nil , "Failure preparing request")
        return
        }

                resp, err := client.CreateMethodSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, ".BaseClient", "CreateMethod", resp, "Failure sending request")
                return
                }

                result, err = client.CreateMethodResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, ".BaseClient", "CreateMethod", resp, "Failure responding to request")
                }

        return
        }

        // CreateMethodPreparer prepares the CreateMethod request.
        func (client BaseClient) CreateMethodPreparer(ctx context.Context, body UserCreateUserType) (*http.Request, error) {
            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json; charset=utf-8"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/users"),
        autorest.WithJSON(body))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // CreateMethodSender sends the CreateMethod request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) CreateMethodSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // CreateMethodResponder handles the response to the CreateMethod request. The method always
    // closes the http.Response Body.
    func (client BaseClient) CreateMethodResponder(resp *http.Response) (result UserUserType, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusAccepted),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // DiscoverKeysMethod sends the discover keys request.
    func (client BaseClient) DiscoverKeysMethod(ctx context.Context) (result DiscoveryKeysType, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.DiscoverKeysMethod")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.DiscoverKeysMethodPreparer(ctx)
        if err != nil {
        err = autorest.NewErrorWithError(err, ".BaseClient", "DiscoverKeysMethod", nil , "Failure preparing request")
        return
        }

                resp, err := client.DiscoverKeysMethodSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, ".BaseClient", "DiscoverKeysMethod", resp, "Failure sending request")
                return
                }

                result, err = client.DiscoverKeysMethodResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, ".BaseClient", "DiscoverKeysMethod", resp, "Failure responding to request")
                }

        return
        }

        // DiscoverKeysMethodPreparer prepares the DiscoverKeysMethod request.
        func (client BaseClient) DiscoverKeysMethodPreparer(ctx context.Context) (*http.Request, error) {
            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/discovery/keys"))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // DiscoverKeysMethodSender sends the DiscoverKeysMethod request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) DiscoverKeysMethodSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // DiscoverKeysMethodResponder handles the response to the DiscoverKeysMethod request. The method always
    // closes the http.Response Body.
    func (client BaseClient) DiscoverKeysMethodResponder(resp *http.Response) (result DiscoveryKeysType, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GenerateAuthCodeMethod sends the generate auth code request.
        // Parameters:
            // userID - identifier of the user
    func (client BaseClient) GenerateAuthCodeMethod(ctx context.Context, userID string) (result UserAuthCodeResponseType, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GenerateAuthCodeMethod")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GenerateAuthCodeMethodPreparer(ctx, userID)
        if err != nil {
        err = autorest.NewErrorWithError(err, ".BaseClient", "GenerateAuthCodeMethod", nil , "Failure preparing request")
        return
        }

                resp, err := client.GenerateAuthCodeMethodSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, ".BaseClient", "GenerateAuthCodeMethod", resp, "Failure sending request")
                return
                }

                result, err = client.GenerateAuthCodeMethodResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, ".BaseClient", "GenerateAuthCodeMethod", resp, "Failure responding to request")
                }

        return
        }

        // GenerateAuthCodeMethodPreparer prepares the GenerateAuthCodeMethod request.
        func (client BaseClient) GenerateAuthCodeMethodPreparer(ctx context.Context, userID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "userId": autorest.Encode("path",userID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/users/{userId}/authcode",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GenerateAuthCodeMethodSender sends the GenerateAuthCodeMethod request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GenerateAuthCodeMethodSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GenerateAuthCodeMethodResponder handles the response to the GenerateAuthCodeMethod request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GenerateAuthCodeMethodResponder(resp *http.Response) (result UserAuthCodeResponseType, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GenerateRequest1Method sends the generate request 1 request.
        // Parameters:
            // tid - the tenant id for this request
            // clientID - the Oauth2 client_id that is making the reqeust
    func (client BaseClient) GenerateRequest1Method(ctx context.Context, tid string, clientID string) (result SamlGenerateRequestResponseType, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GenerateRequest1Method")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GenerateRequest1MethodPreparer(ctx, tid, clientID)
        if err != nil {
        err = autorest.NewErrorWithError(err, ".BaseClient", "GenerateRequest1Method", nil , "Failure preparing request")
        return
        }

                resp, err := client.GenerateRequest1MethodSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, ".BaseClient", "GenerateRequest1Method", resp, "Failure sending request")
                return
                }

                result, err = client.GenerateRequest1MethodResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, ".BaseClient", "GenerateRequest1Method", resp, "Failure responding to request")
                }

        return
        }

        // GenerateRequest1MethodPreparer prepares the GenerateRequest1Method request.
        func (client BaseClient) GenerateRequest1MethodPreparer(ctx context.Context, tid string, clientID string) (*http.Request, error) {
                    queryParameters := map[string]interface{} {
            "tid": autorest.Encode("query",tid),
            }

                formDataParameters := map[string]interface{} {
                "client_id": clientID,
                }

                    preparer := autorest.CreatePreparer(
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/saml/request"),
        autorest.WithQueryParameters(queryParameters),
        autorest.WithFormData(autorest.MapToValues(formDataParameters)))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GenerateRequest1MethodSender sends the GenerateRequest1Method request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GenerateRequest1MethodSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GenerateRequest1MethodResponder handles the response to the GenerateRequest1Method request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GenerateRequest1MethodResponder(resp *http.Response) (result SamlGenerateRequestResponseType, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GenerateRequestMethod sends the generate request request.
        // Parameters:
            // tid - the tenant id for this request
            // sAMLResponse - the SAML AuthNResponse from the Identity Provider
            // relayState - the relay state obtained from generate request process
    func (client BaseClient) GenerateRequestMethod(ctx context.Context, tid string, sAMLResponse string, relayState string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GenerateRequestMethod")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GenerateRequestMethodPreparer(ctx, tid, sAMLResponse, relayState)
        if err != nil {
        err = autorest.NewErrorWithError(err, ".BaseClient", "GenerateRequestMethod", nil , "Failure preparing request")
        return
        }

                resp, err := client.GenerateRequestMethodSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, ".BaseClient", "GenerateRequestMethod", resp, "Failure sending request")
                return
                }

                result, err = client.GenerateRequestMethodResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, ".BaseClient", "GenerateRequestMethod", resp, "Failure responding to request")
                }

        return
        }

        // GenerateRequestMethodPreparer prepares the GenerateRequestMethod request.
        func (client BaseClient) GenerateRequestMethodPreparer(ctx context.Context, tid string, sAMLResponse string, relayState string) (*http.Request, error) {
                    queryParameters := map[string]interface{} {
            "tid": autorest.Encode("query",tid),
            }

                formDataParameters := map[string]interface{} {
                "RelayState": relayState,
                "SAMLResponse": sAMLResponse,
                }

                    preparer := autorest.CreatePreparer(
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/saml/access"),
        autorest.WithQueryParameters(queryParameters),
        autorest.WithFormData(autorest.MapToValues(formDataParameters)))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GenerateRequestMethodSender sends the GenerateRequestMethod request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GenerateRequestMethodSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GenerateRequestMethodResponder handles the response to the GenerateRequestMethod request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GenerateRequestMethodResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusFound),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // GetConfigurationMethod sends the get configuration request.
        // Parameters:
            // tenantID - the tenant id
    func (client BaseClient) GetConfigurationMethod(ctx context.Context, tenantID string) (result TenantConfigurationType, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetConfigurationMethod")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetConfigurationMethodPreparer(ctx, tenantID)
        if err != nil {
        err = autorest.NewErrorWithError(err, ".BaseClient", "GetConfigurationMethod", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetConfigurationMethodSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, ".BaseClient", "GetConfigurationMethod", resp, "Failure sending request")
                return
                }

                result, err = client.GetConfigurationMethodResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, ".BaseClient", "GetConfigurationMethod", resp, "Failure responding to request")
                }

        return
        }

        // GetConfigurationMethodPreparer prepares the GetConfigurationMethod request.
        func (client BaseClient) GetConfigurationMethodPreparer(ctx context.Context, tenantID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "tenantId": autorest.Encode("path",tenantID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/configuration/{tenantId}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetConfigurationMethodSender sends the GetConfigurationMethod request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetConfigurationMethodSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetConfigurationMethodResponder handles the response to the GetConfigurationMethod request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetConfigurationMethodResponder(resp *http.Response) (result TenantConfigurationType, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetMethod sends the get request.
        // Parameters:
            // userID - identifier of the user
    func (client BaseClient) GetMethod(ctx context.Context, userID string) (result UserUserType, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetMethod")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetMethodPreparer(ctx, userID)
        if err != nil {
        err = autorest.NewErrorWithError(err, ".BaseClient", "GetMethod", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetMethodSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, ".BaseClient", "GetMethod", resp, "Failure sending request")
                return
                }

                result, err = client.GetMethodResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, ".BaseClient", "GetMethod", resp, "Failure responding to request")
                }

        return
        }

        // GetMethodPreparer prepares the GetMethod request.
        func (client BaseClient) GetMethodPreparer(ctx context.Context, userID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "userId": autorest.Encode("path",userID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/users/{userId}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetMethodSender sends the GetMethod request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetMethodSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetMethodResponder handles the response to the GetMethod request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetMethodResponder(resp *http.Response) (result UserUserType, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetSAMLSettingsMethod sends the get saml settings request.
        // Parameters:
            // tid - the tenant id for this request
    func (client BaseClient) GetSAMLSettingsMethod(ctx context.Context, tid string) (result SamlSAMLSettingsType, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetSAMLSettingsMethod")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetSAMLSettingsMethodPreparer(ctx, tid)
        if err != nil {
        err = autorest.NewErrorWithError(err, ".BaseClient", "GetSAMLSettingsMethod", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetSAMLSettingsMethodSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, ".BaseClient", "GetSAMLSettingsMethod", resp, "Failure sending request")
                return
                }

                result, err = client.GetSAMLSettingsMethodResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, ".BaseClient", "GetSAMLSettingsMethod", resp, "Failure responding to request")
                }

        return
        }

        // GetSAMLSettingsMethodPreparer prepares the GetSAMLSettingsMethod request.
        func (client BaseClient) GetSAMLSettingsMethodPreparer(ctx context.Context, tid string) (*http.Request, error) {
                    queryParameters := map[string]interface{} {
            "tid": autorest.Encode("query",tid),
            }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/saml/settings"),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetSAMLSettingsMethodSender sends the GetSAMLSettingsMethod request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetSAMLSettingsMethodSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetSAMLSettingsMethodResponder handles the response to the GetSAMLSettingsMethod request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetSAMLSettingsMethodResponder(resp *http.Response) (result SamlSAMLSettingsType, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // TokenMethod sends the token request.
        // Parameters:
            // grantType - the grant_type to use for obtaining a token
            // username - the username used with grant_type=password
            // password - the password used with grant_type=password
            // code - the code to use with grant_type=authorization_code
            // refreshToken - the refresh token to use with grant_type=refresh_token
    func (client BaseClient) TokenMethod(ctx context.Context, grantType string, username string, password string, code string, refreshToken string) (result OauthTokenType, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.TokenMethod")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.TokenMethodPreparer(ctx, grantType, username, password, code, refreshToken)
        if err != nil {
        err = autorest.NewErrorWithError(err, ".BaseClient", "TokenMethod", nil , "Failure preparing request")
        return
        }

                resp, err := client.TokenMethodSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, ".BaseClient", "TokenMethod", resp, "Failure sending request")
                return
                }

                result, err = client.TokenMethodResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, ".BaseClient", "TokenMethod", resp, "Failure responding to request")
                }

        return
        }

        // TokenMethodPreparer prepares the TokenMethod request.
        func (client BaseClient) TokenMethodPreparer(ctx context.Context, grantType string, username string, password string, code string, refreshToken string) (*http.Request, error) {
                formDataParameters := map[string]interface{} {
                "grant_type": grantType,
                }
                    if len(username) > 0 {
                    formDataParameters["username"] = username
                    }
                    if len(password) > 0 {
                    formDataParameters["password"] = password
                    }
                    if len(code) > 0 {
                    formDataParameters["code"] = code
                    }
                    if len(refreshToken) > 0 {
                    formDataParameters["refresh_token"] = refreshToken
                    }

                    preparer := autorest.CreatePreparer(
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/oauth2/token"),
        autorest.WithFormData(autorest.MapToValues(formDataParameters)))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // TokenMethodSender sends the TokenMethod request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) TokenMethodSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // TokenMethodResponder handles the response to the TokenMethod request. The method always
    // closes the http.Response Body.
    func (client BaseClient) TokenMethodResponder(resp *http.Response) (result OauthTokenType, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusForbidden,http.StatusInternalServerError),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // Update1Method sends the update 1 request.
        // Parameters:
            // userID - identifier of the user
    func (client BaseClient) Update1Method(ctx context.Context, userID string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.Update1Method")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.Update1MethodPreparer(ctx, userID)
        if err != nil {
        err = autorest.NewErrorWithError(err, ".BaseClient", "Update1Method", nil , "Failure preparing request")
        return
        }

                resp, err := client.Update1MethodSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, ".BaseClient", "Update1Method", resp, "Failure sending request")
                return
                }

                result, err = client.Update1MethodResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, ".BaseClient", "Update1Method", resp, "Failure responding to request")
                }

        return
        }

        // Update1MethodPreparer prepares the Update1Method request.
        func (client BaseClient) Update1MethodPreparer(ctx context.Context, userID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "userId": autorest.Encode("path",userID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsDelete(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/users/{userId}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // Update1MethodSender sends the Update1Method request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) Update1MethodSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // Update1MethodResponder handles the response to the Update1Method request. The method always
    // closes the http.Response Body.
    func (client BaseClient) Update1MethodResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // UpdateMethod sends the update request.
        // Parameters:
            // userID - identifier of the user
    func (client BaseClient) UpdateMethod(ctx context.Context, userID string, body UserUserType) (result UserUserType, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.UpdateMethod")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.UpdateMethodPreparer(ctx, userID, body)
        if err != nil {
        err = autorest.NewErrorWithError(err, ".BaseClient", "UpdateMethod", nil , "Failure preparing request")
        return
        }

                resp, err := client.UpdateMethodSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, ".BaseClient", "UpdateMethod", resp, "Failure sending request")
                return
                }

                result, err = client.UpdateMethodResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, ".BaseClient", "UpdateMethod", resp, "Failure responding to request")
                }

        return
        }

        // UpdateMethodPreparer prepares the UpdateMethod request.
        func (client BaseClient) UpdateMethodPreparer(ctx context.Context, userID string, body UserUserType) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "userId": autorest.Encode("path",userID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json; charset=utf-8"),
        autorest.AsPut(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/users/{userId}",pathParameters),
        autorest.WithJSON(body))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // UpdateMethodSender sends the UpdateMethod request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) UpdateMethodSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // UpdateMethodResponder handles the response to the UpdateMethod request. The method always
    // closes the http.Response Body.
    func (client BaseClient) UpdateMethodResponder(resp *http.Response) (result UserUserType, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

