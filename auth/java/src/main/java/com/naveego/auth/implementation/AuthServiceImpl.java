/**
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

package com.naveego.auth.implementation;

import com.naveego.auth.AuthService;
import com.microsoft.rest.ServiceClient;
import com.microsoft.rest.RestClient;
import okhttp3.OkHttpClient;
import retrofit2.Retrofit;
import com.google.common.reflect.TypeToken;
import com.microsoft.rest.RestException;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.Validator;
import com.naveego.auth.models.DiscoveryKeys;
import com.naveego.auth.models.DiscoveryKeysException;
import com.naveego.auth.models.OauthToken;
import com.naveego.auth.models.OauthTokenException;
import com.naveego.auth.models.SamlGenerateRequestResponse;
import com.naveego.auth.models.SamlGenerateRequestResponseException;
import com.naveego.auth.models.SamlSAMLSettings;
import com.naveego.auth.models.SamlSAMLSettingsException;
import com.naveego.auth.models.TenantConfiguration;
import com.naveego.auth.models.TenantConfigurationException;
import com.naveego.auth.models.UserAuthCodeResponse;
import com.naveego.auth.models.UserAuthCodeResponseException;
import com.naveego.auth.models.UserCreateUser;
import com.naveego.auth.models.UserLoginRequest;
import com.naveego.auth.models.UserLoginResponse;
import com.naveego.auth.models.UserLoginResponseException;
import com.naveego.auth.models.UserUser;
import com.naveego.auth.models.UserUserException;
import java.io.IOException;
import okhttp3.ResponseBody;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Headers;
import retrofit2.http.HTTP;
import retrofit2.http.Multipart;
import retrofit2.http.Part;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.http.PUT;
import retrofit2.http.Query;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * Initializes a new instance of the AuthService class.
 */
public class AuthServiceImpl extends ServiceClient implements AuthService {
    /**
     * The Retrofit service to perform REST calls.
     */
    private AuthServiceService service;

    /**
     * Initializes an instance of AuthService client.
     */
    public AuthServiceImpl() {
        this("https://");
    }

    /**
     * Initializes an instance of AuthService client.
     *
     * @param baseUrl the base URL of the host
     */
    public AuthServiceImpl(String baseUrl) {
        super(baseUrl);
        initialize();
    }

    /**
     * Initializes an instance of AuthService client.
     *
     * @param clientBuilder the builder for building an OkHttp client, bundled with user configurations
     * @param restBuilder the builder for building an Retrofit client, bundled with user configurations
     */
    public AuthServiceImpl(OkHttpClient.Builder clientBuilder, Retrofit.Builder restBuilder) {
        this("https://", clientBuilder, restBuilder);
        initialize();
    }

    /**
     * Initializes an instance of AuthService client.
     *
     * @param baseUrl the base URL of the host
     * @param clientBuilder the builder for building an OkHttp client, bundled with user configurations
     * @param restBuilder the builder for building an Retrofit client, bundled with user configurations
     */
    public AuthServiceImpl(String baseUrl, OkHttpClient.Builder clientBuilder, Retrofit.Builder restBuilder) {
        super(baseUrl, clientBuilder, restBuilder);
        initialize();
    }

    /**
     * Initializes an instance of AuthService client.
     *
     * @param restClient the REST client containing pre-configured settings
     */
    public AuthServiceImpl(RestClient restClient) {
        super(restClient);
        initialize();
    }

    private void initialize() {
        initializeService();
    }

    private void initializeService() {
        service = retrofit().create(AuthServiceService.class);
    }

    /**
     * The interface defining all the services for AuthService to be
     * used by Retrofit to perform actually REST calls.
     */
    interface AuthServiceService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.naveego.auth.AuthService getConfiguration" })
        @GET("configuration/{tenantId}")
        Observable<Response<ResponseBody>> getConfiguration(@Path("tenantId") String tenantId);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.naveego.auth.AuthService discoverKeys" })
        @GET("discovery/keys")
        Observable<Response<ResponseBody>> discoverKeys();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.naveego.auth.AuthService authorize" })
        @GET("oauth2/authorize")
        Observable<Response<ResponseBody>> authorize();

        @Multipart
        @POST("oauth2/token")
        Observable<Response<ResponseBody>> token(@Part("grant_type") String grantType, @Part("username") String username, @Part("password") String password, @Part("code") String code, @Part("refresh_token") String refreshToken);

        @Multipart
        @POST("saml/access")
        Observable<Response<ResponseBody>> generateRequest(@Query("tid") String tid, @Part("SAMLResponse") String sAMLResponse, @Part("RelayState") String relayState);

        @Multipart
        @POST("saml/request")
        Observable<Response<ResponseBody>> generateRequest1(@Query("tid") String tid, @Part("client_id") String clientId);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.naveego.auth.AuthService getSAMLSettings" })
        @GET("saml/settings")
        Observable<Response<ResponseBody>> getSAMLSettings(@Query("tid") String tid);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.naveego.auth.AuthService create" })
        @POST("users")
        Observable<Response<ResponseBody>> create(@Body UserCreateUser body);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.naveego.auth.AuthService loginUser" })
        @POST("users/login")
        Observable<Response<ResponseBody>> loginUser(@Body UserLoginRequest body);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.naveego.auth.AuthService get" })
        @GET("users/{userId}")
        Observable<Response<ResponseBody>> get(@Path("userId") String userId);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.naveego.auth.AuthService update" })
        @PUT("users/{userId}")
        Observable<Response<ResponseBody>> update(@Path("userId") String userId, @Body UserUser body);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.naveego.auth.AuthService update1" })
        @HTTP(path = "users/{userId}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> update1(@Path("userId") String userId);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.naveego.auth.AuthService generateAuthCode" })
        @GET("users/{userId}/authcode")
        Observable<Response<ResponseBody>> generateAuthCode(@Path("userId") String userId);

    }

    /**
     * get the configuration for a tenant.
     *
     * @param tenantId The tenant id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws TenantConfigurationException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the TenantConfiguration object if successful.
     */
    public TenantConfiguration getConfiguration(String tenantId) {
        return getConfigurationWithServiceResponseAsync(tenantId).toBlocking().single().body();
    }

    /**
     * get the configuration for a tenant.
     *
     * @param tenantId The tenant id
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<TenantConfiguration> getConfigurationAsync(String tenantId, final ServiceCallback<TenantConfiguration> serviceCallback) {
        return ServiceFuture.fromResponse(getConfigurationWithServiceResponseAsync(tenantId), serviceCallback);
    }

    /**
     * get the configuration for a tenant.
     *
     * @param tenantId The tenant id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TenantConfiguration object
     */
    public Observable<TenantConfiguration> getConfigurationAsync(String tenantId) {
        return getConfigurationWithServiceResponseAsync(tenantId).map(new Func1<ServiceResponse<TenantConfiguration>, TenantConfiguration>() {
            @Override
            public TenantConfiguration call(ServiceResponse<TenantConfiguration> response) {
                return response.body();
            }
        });
    }

    /**
     * get the configuration for a tenant.
     *
     * @param tenantId The tenant id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TenantConfiguration object
     */
    public Observable<ServiceResponse<TenantConfiguration>> getConfigurationWithServiceResponseAsync(String tenantId) {
        if (tenantId == null) {
            throw new IllegalArgumentException("Parameter tenantId is required and cannot be null.");
        }
        return service.getConfiguration(tenantId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<TenantConfiguration>>>() {
                @Override
                public Observable<ServiceResponse<TenantConfiguration>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<TenantConfiguration> clientResponse = getConfigurationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<TenantConfiguration> getConfigurationDelegate(Response<ResponseBody> response) throws TenantConfigurationException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<TenantConfiguration, TenantConfigurationException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<TenantConfiguration>() { }.getType())
                .registerError(TenantConfigurationException.class)
                .build(response);
    }

    /**
     * get jwks for key validation.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws DiscoveryKeysException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the DiscoveryKeys object if successful.
     */
    public DiscoveryKeys discoverKeys() {
        return discoverKeysWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * get jwks for key validation.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<DiscoveryKeys> discoverKeysAsync(final ServiceCallback<DiscoveryKeys> serviceCallback) {
        return ServiceFuture.fromResponse(discoverKeysWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * get jwks for key validation.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DiscoveryKeys object
     */
    public Observable<DiscoveryKeys> discoverKeysAsync() {
        return discoverKeysWithServiceResponseAsync().map(new Func1<ServiceResponse<DiscoveryKeys>, DiscoveryKeys>() {
            @Override
            public DiscoveryKeys call(ServiceResponse<DiscoveryKeys> response) {
                return response.body();
            }
        });
    }

    /**
     * get jwks for key validation.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DiscoveryKeys object
     */
    public Observable<ServiceResponse<DiscoveryKeys>> discoverKeysWithServiceResponseAsync() {
        return service.discoverKeys()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<DiscoveryKeys>>>() {
                @Override
                public Observable<ServiceResponse<DiscoveryKeys>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<DiscoveryKeys> clientResponse = discoverKeysDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<DiscoveryKeys> discoverKeysDelegate(Response<ResponseBody> response) throws DiscoveryKeysException, IOException {
        return this.restClient().responseBuilderFactory().<DiscoveryKeys, DiscoveryKeysException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<DiscoveryKeys>() { }.getType())
                .registerError(DiscoveryKeysException.class)
                .build(response);
    }

    /**
     * Oauth2 authorize endpoint.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void authorize() {
        authorizeWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Oauth2 authorize endpoint.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> authorizeAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(authorizeWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Oauth2 authorize endpoint.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> authorizeAsync() {
        return authorizeWithServiceResponseAsync().map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Oauth2 authorize endpoint.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> authorizeWithServiceResponseAsync() {
        return service.authorize()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = authorizeDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> authorizeDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<Void, RestException>newInstance(this.serializerAdapter())
                .register(302, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Oauth2 token endpoint.
     *
     * @param grantType The grant_type to use for obtaining a token
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws OauthTokenException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OauthToken object if successful.
     */
    public OauthToken token(String grantType) {
        return tokenWithServiceResponseAsync(grantType).toBlocking().single().body();
    }

    /**
     * Oauth2 token endpoint.
     *
     * @param grantType The grant_type to use for obtaining a token
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OauthToken> tokenAsync(String grantType, final ServiceCallback<OauthToken> serviceCallback) {
        return ServiceFuture.fromResponse(tokenWithServiceResponseAsync(grantType), serviceCallback);
    }

    /**
     * Oauth2 token endpoint.
     *
     * @param grantType The grant_type to use for obtaining a token
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OauthToken object
     */
    public Observable<OauthToken> tokenAsync(String grantType) {
        return tokenWithServiceResponseAsync(grantType).map(new Func1<ServiceResponse<OauthToken>, OauthToken>() {
            @Override
            public OauthToken call(ServiceResponse<OauthToken> response) {
                return response.body();
            }
        });
    }

    /**
     * Oauth2 token endpoint.
     *
     * @param grantType The grant_type to use for obtaining a token
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OauthToken object
     */
    public Observable<ServiceResponse<OauthToken>> tokenWithServiceResponseAsync(String grantType) {
        if (grantType == null) {
            throw new IllegalArgumentException("Parameter grantType is required and cannot be null.");
        }
        final String username = null;
        final String password = null;
        final String code = null;
        final String refreshToken = null;
        return service.token(grantType, username, password, code, refreshToken)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OauthToken>>>() {
                @Override
                public Observable<ServiceResponse<OauthToken>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OauthToken> clientResponse = tokenDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Oauth2 token endpoint.
     *
     * @param grantType The grant_type to use for obtaining a token
     * @param username The username used with grant_type=password
     * @param password The password used with grant_type=password
     * @param code The code to use with grant_type=authorization_code
     * @param refreshToken The refresh token to use with grant_type=refresh_token
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws OauthTokenException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OauthToken object if successful.
     */
    public OauthToken token(String grantType, String username, String password, String code, String refreshToken) {
        return tokenWithServiceResponseAsync(grantType, username, password, code, refreshToken).toBlocking().single().body();
    }

    /**
     * Oauth2 token endpoint.
     *
     * @param grantType The grant_type to use for obtaining a token
     * @param username The username used with grant_type=password
     * @param password The password used with grant_type=password
     * @param code The code to use with grant_type=authorization_code
     * @param refreshToken The refresh token to use with grant_type=refresh_token
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OauthToken> tokenAsync(String grantType, String username, String password, String code, String refreshToken, final ServiceCallback<OauthToken> serviceCallback) {
        return ServiceFuture.fromResponse(tokenWithServiceResponseAsync(grantType, username, password, code, refreshToken), serviceCallback);
    }

    /**
     * Oauth2 token endpoint.
     *
     * @param grantType The grant_type to use for obtaining a token
     * @param username The username used with grant_type=password
     * @param password The password used with grant_type=password
     * @param code The code to use with grant_type=authorization_code
     * @param refreshToken The refresh token to use with grant_type=refresh_token
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OauthToken object
     */
    public Observable<OauthToken> tokenAsync(String grantType, String username, String password, String code, String refreshToken) {
        return tokenWithServiceResponseAsync(grantType, username, password, code, refreshToken).map(new Func1<ServiceResponse<OauthToken>, OauthToken>() {
            @Override
            public OauthToken call(ServiceResponse<OauthToken> response) {
                return response.body();
            }
        });
    }

    /**
     * Oauth2 token endpoint.
     *
     * @param grantType The grant_type to use for obtaining a token
     * @param username The username used with grant_type=password
     * @param password The password used with grant_type=password
     * @param code The code to use with grant_type=authorization_code
     * @param refreshToken The refresh token to use with grant_type=refresh_token
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OauthToken object
     */
    public Observable<ServiceResponse<OauthToken>> tokenWithServiceResponseAsync(String grantType, String username, String password, String code, String refreshToken) {
        if (grantType == null) {
            throw new IllegalArgumentException("Parameter grantType is required and cannot be null.");
        }
        return service.token(grantType, username, password, code, refreshToken)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OauthToken>>>() {
                @Override
                public Observable<ServiceResponse<OauthToken>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OauthToken> clientResponse = tokenDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<OauthToken> tokenDelegate(Response<ResponseBody> response) throws OauthTokenException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<OauthToken, OauthTokenException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<OauthToken>() { }.getType())
                .register(400, new TypeToken<Void>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .registerError(OauthTokenException.class)
                .build(response);
    }

    /**
     * Redirects user back to target login endpoint.
     *
     * @param tid The tenant id for this request
     * @param sAMLResponse The SAML AuthNResponse from the Identity Provider
     * @param relayState The relay state obtained from generate request process
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void generateRequest(String tid, String sAMLResponse, String relayState) {
        generateRequestWithServiceResponseAsync(tid, sAMLResponse, relayState).toBlocking().single().body();
    }

    /**
     * Redirects user back to target login endpoint.
     *
     * @param tid The tenant id for this request
     * @param sAMLResponse The SAML AuthNResponse from the Identity Provider
     * @param relayState The relay state obtained from generate request process
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> generateRequestAsync(String tid, String sAMLResponse, String relayState, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(generateRequestWithServiceResponseAsync(tid, sAMLResponse, relayState), serviceCallback);
    }

    /**
     * Redirects user back to target login endpoint.
     *
     * @param tid The tenant id for this request
     * @param sAMLResponse The SAML AuthNResponse from the Identity Provider
     * @param relayState The relay state obtained from generate request process
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> generateRequestAsync(String tid, String sAMLResponse, String relayState) {
        return generateRequestWithServiceResponseAsync(tid, sAMLResponse, relayState).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Redirects user back to target login endpoint.
     *
     * @param tid The tenant id for this request
     * @param sAMLResponse The SAML AuthNResponse from the Identity Provider
     * @param relayState The relay state obtained from generate request process
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> generateRequestWithServiceResponseAsync(String tid, String sAMLResponse, String relayState) {
        if (tid == null) {
            throw new IllegalArgumentException("Parameter tid is required and cannot be null.");
        }
        if (sAMLResponse == null) {
            throw new IllegalArgumentException("Parameter sAMLResponse is required and cannot be null.");
        }
        if (relayState == null) {
            throw new IllegalArgumentException("Parameter relayState is required and cannot be null.");
        }
        return service.generateRequest(tid, sAMLResponse, relayState)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = generateRequestDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> generateRequestDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, RestException>newInstance(this.serializerAdapter())
                .register(302, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Generates a SAML request.
     *
     * @param tid The tenant id for this request
     * @param clientId The Oauth2 client_id that is making the reqeust
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws SamlGenerateRequestResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SamlGenerateRequestResponse object if successful.
     */
    public SamlGenerateRequestResponse generateRequest1(String tid, String clientId) {
        return generateRequest1WithServiceResponseAsync(tid, clientId).toBlocking().single().body();
    }

    /**
     * Generates a SAML request.
     *
     * @param tid The tenant id for this request
     * @param clientId The Oauth2 client_id that is making the reqeust
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SamlGenerateRequestResponse> generateRequest1Async(String tid, String clientId, final ServiceCallback<SamlGenerateRequestResponse> serviceCallback) {
        return ServiceFuture.fromResponse(generateRequest1WithServiceResponseAsync(tid, clientId), serviceCallback);
    }

    /**
     * Generates a SAML request.
     *
     * @param tid The tenant id for this request
     * @param clientId The Oauth2 client_id that is making the reqeust
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SamlGenerateRequestResponse object
     */
    public Observable<SamlGenerateRequestResponse> generateRequest1Async(String tid, String clientId) {
        return generateRequest1WithServiceResponseAsync(tid, clientId).map(new Func1<ServiceResponse<SamlGenerateRequestResponse>, SamlGenerateRequestResponse>() {
            @Override
            public SamlGenerateRequestResponse call(ServiceResponse<SamlGenerateRequestResponse> response) {
                return response.body();
            }
        });
    }

    /**
     * Generates a SAML request.
     *
     * @param tid The tenant id for this request
     * @param clientId The Oauth2 client_id that is making the reqeust
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SamlGenerateRequestResponse object
     */
    public Observable<ServiceResponse<SamlGenerateRequestResponse>> generateRequest1WithServiceResponseAsync(String tid, String clientId) {
        if (tid == null) {
            throw new IllegalArgumentException("Parameter tid is required and cannot be null.");
        }
        if (clientId == null) {
            throw new IllegalArgumentException("Parameter clientId is required and cannot be null.");
        }
        return service.generateRequest1(tid, clientId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SamlGenerateRequestResponse>>>() {
                @Override
                public Observable<ServiceResponse<SamlGenerateRequestResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SamlGenerateRequestResponse> clientResponse = generateRequest1Delegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SamlGenerateRequestResponse> generateRequest1Delegate(Response<ResponseBody> response) throws SamlGenerateRequestResponseException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<SamlGenerateRequestResponse, SamlGenerateRequestResponseException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<SamlGenerateRequestResponse>() { }.getType())
                .registerError(SamlGenerateRequestResponseException.class)
                .build(response);
    }

    /**
     * Gets the SAML settings for this tenant.
     *
     * @param tid The tenant id for this request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws SamlSAMLSettingsException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SamlSAMLSettings object if successful.
     */
    public SamlSAMLSettings getSAMLSettings(String tid) {
        return getSAMLSettingsWithServiceResponseAsync(tid).toBlocking().single().body();
    }

    /**
     * Gets the SAML settings for this tenant.
     *
     * @param tid The tenant id for this request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SamlSAMLSettings> getSAMLSettingsAsync(String tid, final ServiceCallback<SamlSAMLSettings> serviceCallback) {
        return ServiceFuture.fromResponse(getSAMLSettingsWithServiceResponseAsync(tid), serviceCallback);
    }

    /**
     * Gets the SAML settings for this tenant.
     *
     * @param tid The tenant id for this request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SamlSAMLSettings object
     */
    public Observable<SamlSAMLSettings> getSAMLSettingsAsync(String tid) {
        return getSAMLSettingsWithServiceResponseAsync(tid).map(new Func1<ServiceResponse<SamlSAMLSettings>, SamlSAMLSettings>() {
            @Override
            public SamlSAMLSettings call(ServiceResponse<SamlSAMLSettings> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the SAML settings for this tenant.
     *
     * @param tid The tenant id for this request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SamlSAMLSettings object
     */
    public Observable<ServiceResponse<SamlSAMLSettings>> getSAMLSettingsWithServiceResponseAsync(String tid) {
        if (tid == null) {
            throw new IllegalArgumentException("Parameter tid is required and cannot be null.");
        }
        return service.getSAMLSettings(tid)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SamlSAMLSettings>>>() {
                @Override
                public Observable<ServiceResponse<SamlSAMLSettings>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SamlSAMLSettings> clientResponse = getSAMLSettingsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SamlSAMLSettings> getSAMLSettingsDelegate(Response<ResponseBody> response) throws SamlSAMLSettingsException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<SamlSAMLSettings, SamlSAMLSettingsException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<SamlSAMLSettings>() { }.getType())
                .registerError(SamlSAMLSettingsException.class)
                .build(response);
    }

    /**
     * Create a user.
     *
     * @param body the UserCreateUser value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the UserUser object if successful.
     */
    public UserUser create(UserCreateUser body) {
        return createWithServiceResponseAsync(body).toBlocking().single().body();
    }

    /**
     * Create a user.
     *
     * @param body the UserCreateUser value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<UserUser> createAsync(UserCreateUser body, final ServiceCallback<UserUser> serviceCallback) {
        return ServiceFuture.fromResponse(createWithServiceResponseAsync(body), serviceCallback);
    }

    /**
     * Create a user.
     *
     * @param body the UserCreateUser value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UserUser object
     */
    public Observable<UserUser> createAsync(UserCreateUser body) {
        return createWithServiceResponseAsync(body).map(new Func1<ServiceResponse<UserUser>, UserUser>() {
            @Override
            public UserUser call(ServiceResponse<UserUser> response) {
                return response.body();
            }
        });
    }

    /**
     * Create a user.
     *
     * @param body the UserCreateUser value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UserUser object
     */
    public Observable<ServiceResponse<UserUser>> createWithServiceResponseAsync(UserCreateUser body) {
        if (body == null) {
            throw new IllegalArgumentException("Parameter body is required and cannot be null.");
        }
        Validator.validate(body);
        return service.create(body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<UserUser>>>() {
                @Override
                public Observable<ServiceResponse<UserUser>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<UserUser> clientResponse = createDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<UserUser> createDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<UserUser, RestException>newInstance(this.serializerAdapter())
                .register(202, new TypeToken<UserUser>() { }.getType())
                .build(response);
    }

    /**
     * Provides a login endpoint that can generate an auth code for the user given valid user credentials.
     *
     * @param body the UserLoginRequest value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws UserLoginResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the UserLoginResponse object if successful.
     */
    public UserLoginResponse loginUser(UserLoginRequest body) {
        return loginUserWithServiceResponseAsync(body).toBlocking().single().body();
    }

    /**
     * Provides a login endpoint that can generate an auth code for the user given valid user credentials.
     *
     * @param body the UserLoginRequest value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<UserLoginResponse> loginUserAsync(UserLoginRequest body, final ServiceCallback<UserLoginResponse> serviceCallback) {
        return ServiceFuture.fromResponse(loginUserWithServiceResponseAsync(body), serviceCallback);
    }

    /**
     * Provides a login endpoint that can generate an auth code for the user given valid user credentials.
     *
     * @param body the UserLoginRequest value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UserLoginResponse object
     */
    public Observable<UserLoginResponse> loginUserAsync(UserLoginRequest body) {
        return loginUserWithServiceResponseAsync(body).map(new Func1<ServiceResponse<UserLoginResponse>, UserLoginResponse>() {
            @Override
            public UserLoginResponse call(ServiceResponse<UserLoginResponse> response) {
                return response.body();
            }
        });
    }

    /**
     * Provides a login endpoint that can generate an auth code for the user given valid user credentials.
     *
     * @param body the UserLoginRequest value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UserLoginResponse object
     */
    public Observable<ServiceResponse<UserLoginResponse>> loginUserWithServiceResponseAsync(UserLoginRequest body) {
        if (body == null) {
            throw new IllegalArgumentException("Parameter body is required and cannot be null.");
        }
        Validator.validate(body);
        return service.loginUser(body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<UserLoginResponse>>>() {
                @Override
                public Observable<ServiceResponse<UserLoginResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<UserLoginResponse> clientResponse = loginUserDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<UserLoginResponse> loginUserDelegate(Response<ResponseBody> response) throws UserLoginResponseException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<UserLoginResponse, UserLoginResponseException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<UserLoginResponse>() { }.getType())
                .registerError(UserLoginResponseException.class)
                .build(response);
    }

    /**
     * Gets a user.
     *
     * @param userId identifier of the user
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws UserUserException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the UserUser object if successful.
     */
    public UserUser get(String userId) {
        return getWithServiceResponseAsync(userId).toBlocking().single().body();
    }

    /**
     * Gets a user.
     *
     * @param userId identifier of the user
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<UserUser> getAsync(String userId, final ServiceCallback<UserUser> serviceCallback) {
        return ServiceFuture.fromResponse(getWithServiceResponseAsync(userId), serviceCallback);
    }

    /**
     * Gets a user.
     *
     * @param userId identifier of the user
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UserUser object
     */
    public Observable<UserUser> getAsync(String userId) {
        return getWithServiceResponseAsync(userId).map(new Func1<ServiceResponse<UserUser>, UserUser>() {
            @Override
            public UserUser call(ServiceResponse<UserUser> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a user.
     *
     * @param userId identifier of the user
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UserUser object
     */
    public Observable<ServiceResponse<UserUser>> getWithServiceResponseAsync(String userId) {
        if (userId == null) {
            throw new IllegalArgumentException("Parameter userId is required and cannot be null.");
        }
        return service.get(userId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<UserUser>>>() {
                @Override
                public Observable<ServiceResponse<UserUser>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<UserUser> clientResponse = getDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<UserUser> getDelegate(Response<ResponseBody> response) throws UserUserException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<UserUser, UserUserException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<UserUser>() { }.getType())
                .registerError(UserUserException.class)
                .build(response);
    }

    /**
     * Updates a user.
     *
     * @param userId identifier of the user
     * @param body the UserUser value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws UserUserException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the UserUser object if successful.
     */
    public UserUser update(String userId, UserUser body) {
        return updateWithServiceResponseAsync(userId, body).toBlocking().single().body();
    }

    /**
     * Updates a user.
     *
     * @param userId identifier of the user
     * @param body the UserUser value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<UserUser> updateAsync(String userId, UserUser body, final ServiceCallback<UserUser> serviceCallback) {
        return ServiceFuture.fromResponse(updateWithServiceResponseAsync(userId, body), serviceCallback);
    }

    /**
     * Updates a user.
     *
     * @param userId identifier of the user
     * @param body the UserUser value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UserUser object
     */
    public Observable<UserUser> updateAsync(String userId, UserUser body) {
        return updateWithServiceResponseAsync(userId, body).map(new Func1<ServiceResponse<UserUser>, UserUser>() {
            @Override
            public UserUser call(ServiceResponse<UserUser> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates a user.
     *
     * @param userId identifier of the user
     * @param body the UserUser value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UserUser object
     */
    public Observable<ServiceResponse<UserUser>> updateWithServiceResponseAsync(String userId, UserUser body) {
        if (userId == null) {
            throw new IllegalArgumentException("Parameter userId is required and cannot be null.");
        }
        if (body == null) {
            throw new IllegalArgumentException("Parameter body is required and cannot be null.");
        }
        Validator.validate(body);
        return service.update(userId, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<UserUser>>>() {
                @Override
                public Observable<ServiceResponse<UserUser>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<UserUser> clientResponse = updateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<UserUser> updateDelegate(Response<ResponseBody> response) throws UserUserException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<UserUser, UserUserException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<UserUser>() { }.getType())
                .registerError(UserUserException.class)
                .build(response);
    }

    /**
     * Updates a user.
     *
     * @param userId identifier of the user
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void update1(String userId) {
        update1WithServiceResponseAsync(userId).toBlocking().single().body();
    }

    /**
     * Updates a user.
     *
     * @param userId identifier of the user
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> update1Async(String userId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(update1WithServiceResponseAsync(userId), serviceCallback);
    }

    /**
     * Updates a user.
     *
     * @param userId identifier of the user
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> update1Async(String userId) {
        return update1WithServiceResponseAsync(userId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates a user.
     *
     * @param userId identifier of the user
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> update1WithServiceResponseAsync(String userId) {
        if (userId == null) {
            throw new IllegalArgumentException("Parameter userId is required and cannot be null.");
        }
        return service.update1(userId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = update1Delegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> update1Delegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Gets an auth code for the user to use for logging in.
     *
     * @param userId identifier of the user
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws UserAuthCodeResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the UserAuthCodeResponse object if successful.
     */
    public UserAuthCodeResponse generateAuthCode(String userId) {
        return generateAuthCodeWithServiceResponseAsync(userId).toBlocking().single().body();
    }

    /**
     * Gets an auth code for the user to use for logging in.
     *
     * @param userId identifier of the user
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<UserAuthCodeResponse> generateAuthCodeAsync(String userId, final ServiceCallback<UserAuthCodeResponse> serviceCallback) {
        return ServiceFuture.fromResponse(generateAuthCodeWithServiceResponseAsync(userId), serviceCallback);
    }

    /**
     * Gets an auth code for the user to use for logging in.
     *
     * @param userId identifier of the user
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UserAuthCodeResponse object
     */
    public Observable<UserAuthCodeResponse> generateAuthCodeAsync(String userId) {
        return generateAuthCodeWithServiceResponseAsync(userId).map(new Func1<ServiceResponse<UserAuthCodeResponse>, UserAuthCodeResponse>() {
            @Override
            public UserAuthCodeResponse call(ServiceResponse<UserAuthCodeResponse> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets an auth code for the user to use for logging in.
     *
     * @param userId identifier of the user
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UserAuthCodeResponse object
     */
    public Observable<ServiceResponse<UserAuthCodeResponse>> generateAuthCodeWithServiceResponseAsync(String userId) {
        if (userId == null) {
            throw new IllegalArgumentException("Parameter userId is required and cannot be null.");
        }
        return service.generateAuthCode(userId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<UserAuthCodeResponse>>>() {
                @Override
                public Observable<ServiceResponse<UserAuthCodeResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<UserAuthCodeResponse> clientResponse = generateAuthCodeDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<UserAuthCodeResponse> generateAuthCodeDelegate(Response<ResponseBody> response) throws UserAuthCodeResponseException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<UserAuthCodeResponse, UserAuthCodeResponseException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<UserAuthCodeResponse>() { }.getType())
                .registerError(UserAuthCodeResponseException.class)
                .build(response);
    }

}
