// Package  implements the Azure ARM  service API version 1.0.
//
// API surface for Metabase. Application version is 0.0.0. NRN is
// nv1:n5o.red::metabase:self/metabase-67d56f4ff7-hfg4z@0.0.0
package

// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
    "context"
    "github.com/Azure/go-autorest/autorest"
    "github.com/Azure/go-autorest/autorest/azure"
    "github.com/Azure/go-autorest/autorest/validation"
    "github.com/Azure/go-autorest/tracing"
    "net/http"
)

const (
// DefaultBaseURI is the default URI used for the service
DefaultBaseURI = "http://metabase.n5o.red")

// BaseClient is the base client for .
type BaseClient struct {
    autorest.Client
    BaseURI string
}

// New creates an instance of the BaseClient client.
func New()BaseClient {
    return NewWithBaseURI(DefaultBaseURI, )
}

// NewWithBaseURI creates an instance of the BaseClient client.
func NewWithBaseURI(baseURI string, ) BaseClient {
    return BaseClient{
        Client: autorest.NewClientWithUserAgent(UserAgent()),
        BaseURI: baseURI,
    }
}

    // CreateBatchMethod sends the create batch request.
    func (client BaseClient) CreateBatchMethod(ctx context.Context, input BatchType) (result SetObjectType, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.CreateBatchMethod")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                if err := validation.Validate([]validation.Validation{
                { TargetValue: input,
                 Constraints: []validation.Constraint{	{Target: "input.Name", Name: validation.Null, Rule: true, Chain: nil },
                	{Target: "input.JobID", Name: validation.Null, Rule: true, Chain: nil }}}}); err != nil {
                return result, validation.NewError(".BaseClient", "CreateBatchMethod", err.Error())
                }

                    req, err := client.CreateBatchMethodPreparer(ctx, input)
        if err != nil {
        err = autorest.NewErrorWithError(err, ".BaseClient", "CreateBatchMethod", nil , "Failure preparing request")
        return
        }

                resp, err := client.CreateBatchMethodSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, ".BaseClient", "CreateBatchMethod", resp, "Failure sending request")
                return
                }

                result, err = client.CreateBatchMethodResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, ".BaseClient", "CreateBatchMethod", resp, "Failure responding to request")
                }

        return
        }

        // CreateBatchMethodPreparer prepares the CreateBatchMethod request.
        func (client BaseClient) CreateBatchMethodPreparer(ctx context.Context, input BatchType) (*http.Request, error) {
            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v1/batches"),
        autorest.WithJSON(input))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // CreateBatchMethodSender sends the CreateBatchMethod request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) CreateBatchMethodSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // CreateBatchMethodResponder handles the response to the CreateBatchMethod request. The method always
    // closes the http.Response Body.
    func (client BaseClient) CreateBatchMethodResponder(resp *http.Response) (result SetObjectType, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusCreated,http.StatusBadRequest),
        autorest.ByUnmarshallingJSON(&result.Value),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // CreateConnectionMethod sends the create connection request.
    func (client BaseClient) CreateConnectionMethod(ctx context.Context, input ConnectionType) (result SetObjectType, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.CreateConnectionMethod")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                if err := validation.Validate([]validation.Validation{
                { TargetValue: input,
                 Constraints: []validation.Constraint{	{Target: "input.Name", Name: validation.Null, Rule: true, Chain: nil },
                	{Target: "input.Plugin", Name: validation.Null, Rule: true, Chain: nil }}}}); err != nil {
                return result, validation.NewError(".BaseClient", "CreateConnectionMethod", err.Error())
                }

                    req, err := client.CreateConnectionMethodPreparer(ctx, input)
        if err != nil {
        err = autorest.NewErrorWithError(err, ".BaseClient", "CreateConnectionMethod", nil , "Failure preparing request")
        return
        }

                resp, err := client.CreateConnectionMethodSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, ".BaseClient", "CreateConnectionMethod", resp, "Failure sending request")
                return
                }

                result, err = client.CreateConnectionMethodResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, ".BaseClient", "CreateConnectionMethod", resp, "Failure responding to request")
                }

        return
        }

        // CreateConnectionMethodPreparer prepares the CreateConnectionMethod request.
        func (client BaseClient) CreateConnectionMethodPreparer(ctx context.Context, input ConnectionType) (*http.Request, error) {
            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v1/connections"),
        autorest.WithJSON(input))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // CreateConnectionMethodSender sends the CreateConnectionMethod request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) CreateConnectionMethodSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // CreateConnectionMethodResponder handles the response to the CreateConnectionMethod request. The method always
    // closes the http.Response Body.
    func (client BaseClient) CreateConnectionMethodResponder(resp *http.Response) (result SetObjectType, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusCreated,http.StatusBadRequest),
        autorest.ByUnmarshallingJSON(&result.Value),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // CreateFlowMethod sends the create flow request.
    func (client BaseClient) CreateFlowMethod(ctx context.Context, input FlowType) (result SetObjectType, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.CreateFlowMethod")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                if err := validation.Validate([]validation.Validation{
                { TargetValue: input,
                 Constraints: []validation.Constraint{	{Target: "input.Name", Name: validation.Null, Rule: true, Chain: nil }}}}); err != nil {
                return result, validation.NewError(".BaseClient", "CreateFlowMethod", err.Error())
                }

                    req, err := client.CreateFlowMethodPreparer(ctx, input)
        if err != nil {
        err = autorest.NewErrorWithError(err, ".BaseClient", "CreateFlowMethod", nil , "Failure preparing request")
        return
        }

                resp, err := client.CreateFlowMethodSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, ".BaseClient", "CreateFlowMethod", resp, "Failure sending request")
                return
                }

                result, err = client.CreateFlowMethodResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, ".BaseClient", "CreateFlowMethod", resp, "Failure responding to request")
                }

        return
        }

        // CreateFlowMethodPreparer prepares the CreateFlowMethod request.
        func (client BaseClient) CreateFlowMethodPreparer(ctx context.Context, input FlowType) (*http.Request, error) {
            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v1/flows"),
        autorest.WithJSON(input))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // CreateFlowMethodSender sends the CreateFlowMethod request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) CreateFlowMethodSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // CreateFlowMethodResponder handles the response to the CreateFlowMethod request. The method always
    // closes the http.Response Body.
    func (client BaseClient) CreateFlowMethodResponder(resp *http.Response) (result SetObjectType, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusCreated,http.StatusBadRequest),
        autorest.ByUnmarshallingJSON(&result.Value),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // CreateJobMethod sends the create job request.
    func (client BaseClient) CreateJobMethod(ctx context.Context, input JobType) (result SetObjectType, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.CreateJobMethod")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                if err := validation.Validate([]validation.Validation{
                { TargetValue: input,
                 Constraints: []validation.Constraint{	{Target: "input.Name", Name: validation.Null, Rule: true, Chain: nil },
                	{Target: "input.Writeback", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "input.Writeback.WritebackID", Name: validation.Null, Rule: true, Chain: nil },
                }},
                	{Target: "input.LatestBatch", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "input.LatestBatch.Name", Name: validation.Null, Rule: true, Chain: nil },
                	{Target: "input.LatestBatch.JobID", Name: validation.Null, Rule: true, Chain: nil },
                }}}}}); err != nil {
                return result, validation.NewError(".BaseClient", "CreateJobMethod", err.Error())
                }

                    req, err := client.CreateJobMethodPreparer(ctx, input)
        if err != nil {
        err = autorest.NewErrorWithError(err, ".BaseClient", "CreateJobMethod", nil , "Failure preparing request")
        return
        }

                resp, err := client.CreateJobMethodSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, ".BaseClient", "CreateJobMethod", resp, "Failure sending request")
                return
                }

                result, err = client.CreateJobMethodResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, ".BaseClient", "CreateJobMethod", resp, "Failure responding to request")
                }

        return
        }

        // CreateJobMethodPreparer prepares the CreateJobMethod request.
        func (client BaseClient) CreateJobMethodPreparer(ctx context.Context, input JobType) (*http.Request, error) {
            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v1/jobs"),
        autorest.WithJSON(input))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // CreateJobMethodSender sends the CreateJobMethod request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) CreateJobMethodSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // CreateJobMethodResponder handles the response to the CreateJobMethod request. The method always
    // closes the http.Response Body.
    func (client BaseClient) CreateJobMethodResponder(resp *http.Response) (result SetObjectType, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusCreated,http.StatusBadRequest),
        autorest.ByUnmarshallingJSON(&result.Value),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // CreateSchemaMethod sends the create schema request.
    func (client BaseClient) CreateSchemaMethod(ctx context.Context, input SchemaType) (result SetObjectType, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.CreateSchemaMethod")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                if err := validation.Validate([]validation.Validation{
                { TargetValue: input,
                 Constraints: []validation.Constraint{	{Target: "input.Name", Name: validation.Null, Rule: true, Chain: nil }}}}); err != nil {
                return result, validation.NewError(".BaseClient", "CreateSchemaMethod", err.Error())
                }

                    req, err := client.CreateSchemaMethodPreparer(ctx, input)
        if err != nil {
        err = autorest.NewErrorWithError(err, ".BaseClient", "CreateSchemaMethod", nil , "Failure preparing request")
        return
        }

                resp, err := client.CreateSchemaMethodSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, ".BaseClient", "CreateSchemaMethod", resp, "Failure sending request")
                return
                }

                result, err = client.CreateSchemaMethodResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, ".BaseClient", "CreateSchemaMethod", resp, "Failure responding to request")
                }

        return
        }

        // CreateSchemaMethodPreparer prepares the CreateSchemaMethod request.
        func (client BaseClient) CreateSchemaMethodPreparer(ctx context.Context, input SchemaType) (*http.Request, error) {
            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v1/schemas"),
        autorest.WithJSON(input))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // CreateSchemaMethodSender sends the CreateSchemaMethod request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) CreateSchemaMethodSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // CreateSchemaMethodResponder handles the response to the CreateSchemaMethod request. The method always
    // closes the http.Response Body.
    func (client BaseClient) CreateSchemaMethodResponder(resp *http.Response) (result SetObjectType, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusCreated,http.StatusBadRequest),
        autorest.ByUnmarshallingJSON(&result.Value),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // CreateSchemaProfileMethod sends the create schema profile request.
    func (client BaseClient) CreateSchemaProfileMethod(ctx context.Context, input SchemaProfileType) (result SetObjectType, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.CreateSchemaProfileMethod")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                if err := validation.Validate([]validation.Validation{
                { TargetValue: input,
                 Constraints: []validation.Constraint{	{Target: "input.Name", Name: validation.Null, Rule: true, Chain: nil }}}}); err != nil {
                return result, validation.NewError(".BaseClient", "CreateSchemaProfileMethod", err.Error())
                }

                    req, err := client.CreateSchemaProfileMethodPreparer(ctx, input)
        if err != nil {
        err = autorest.NewErrorWithError(err, ".BaseClient", "CreateSchemaProfileMethod", nil , "Failure preparing request")
        return
        }

                resp, err := client.CreateSchemaProfileMethodSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, ".BaseClient", "CreateSchemaProfileMethod", resp, "Failure sending request")
                return
                }

                result, err = client.CreateSchemaProfileMethodResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, ".BaseClient", "CreateSchemaProfileMethod", resp, "Failure responding to request")
                }

        return
        }

        // CreateSchemaProfileMethodPreparer prepares the CreateSchemaProfileMethod request.
        func (client BaseClient) CreateSchemaProfileMethodPreparer(ctx context.Context, input SchemaProfileType) (*http.Request, error) {
            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v1/schemaprofiles"),
        autorest.WithJSON(input))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // CreateSchemaProfileMethodSender sends the CreateSchemaProfileMethod request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) CreateSchemaProfileMethodSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // CreateSchemaProfileMethodResponder handles the response to the CreateSchemaProfileMethod request. The method always
    // closes the http.Response Body.
    func (client BaseClient) CreateSchemaProfileMethodResponder(resp *http.Response) (result SetObjectType, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusCreated,http.StatusBadRequest),
        autorest.ByUnmarshallingJSON(&result.Value),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // CreateShapeMethod sends the create shape request.
    func (client BaseClient) CreateShapeMethod(ctx context.Context, input ShapeType) (result SetObjectType, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.CreateShapeMethod")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                if err := validation.Validate([]validation.Validation{
                { TargetValue: input,
                 Constraints: []validation.Constraint{	{Target: "input.Name", Name: validation.Null, Rule: true, Chain: nil },
                	{Target: "input.MatchRule", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "input.MatchRule.ShapeID", Name: validation.Null, Rule: true, Chain: nil },
                	{Target: "input.MatchRule.Type", Name: validation.Null, Rule: true, Chain: nil },
                }}}}}); err != nil {
                return result, validation.NewError(".BaseClient", "CreateShapeMethod", err.Error())
                }

                    req, err := client.CreateShapeMethodPreparer(ctx, input)
        if err != nil {
        err = autorest.NewErrorWithError(err, ".BaseClient", "CreateShapeMethod", nil , "Failure preparing request")
        return
        }

                resp, err := client.CreateShapeMethodSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, ".BaseClient", "CreateShapeMethod", resp, "Failure sending request")
                return
                }

                result, err = client.CreateShapeMethodResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, ".BaseClient", "CreateShapeMethod", resp, "Failure responding to request")
                }

        return
        }

        // CreateShapeMethodPreparer prepares the CreateShapeMethod request.
        func (client BaseClient) CreateShapeMethodPreparer(ctx context.Context, input ShapeType) (*http.Request, error) {
            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v1/shapes"),
        autorest.WithJSON(input))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // CreateShapeMethodSender sends the CreateShapeMethod request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) CreateShapeMethodSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // CreateShapeMethodResponder handles the response to the CreateShapeMethod request. The method always
    // closes the http.Response Body.
    func (client BaseClient) CreateShapeMethodResponder(resp *http.Response) (result SetObjectType, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusCreated,http.StatusBadRequest),
        autorest.ByUnmarshallingJSON(&result.Value),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // DeleteBatchMethod sends the delete batch request.
    func (client BaseClient) DeleteBatchMethod(ctx context.Context, ID string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.DeleteBatchMethod")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.DeleteBatchMethodPreparer(ctx, ID)
        if err != nil {
        err = autorest.NewErrorWithError(err, ".BaseClient", "DeleteBatchMethod", nil , "Failure preparing request")
        return
        }

                resp, err := client.DeleteBatchMethodSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, ".BaseClient", "DeleteBatchMethod", resp, "Failure sending request")
                return
                }

                result, err = client.DeleteBatchMethodResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, ".BaseClient", "DeleteBatchMethod", resp, "Failure responding to request")
                }

        return
        }

        // DeleteBatchMethodPreparer prepares the DeleteBatchMethod request.
        func (client BaseClient) DeleteBatchMethodPreparer(ctx context.Context, ID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsDelete(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v1/batches/{id}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // DeleteBatchMethodSender sends the DeleteBatchMethod request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) DeleteBatchMethodSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // DeleteBatchMethodResponder handles the response to the DeleteBatchMethod request. The method always
    // closes the http.Response Body.
    func (client BaseClient) DeleteBatchMethodResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // DeleteConnectionMethod sends the delete connection request.
    func (client BaseClient) DeleteConnectionMethod(ctx context.Context, ID string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.DeleteConnectionMethod")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.DeleteConnectionMethodPreparer(ctx, ID)
        if err != nil {
        err = autorest.NewErrorWithError(err, ".BaseClient", "DeleteConnectionMethod", nil , "Failure preparing request")
        return
        }

                resp, err := client.DeleteConnectionMethodSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, ".BaseClient", "DeleteConnectionMethod", resp, "Failure sending request")
                return
                }

                result, err = client.DeleteConnectionMethodResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, ".BaseClient", "DeleteConnectionMethod", resp, "Failure responding to request")
                }

        return
        }

        // DeleteConnectionMethodPreparer prepares the DeleteConnectionMethod request.
        func (client BaseClient) DeleteConnectionMethodPreparer(ctx context.Context, ID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsDelete(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v1/connections/{id}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // DeleteConnectionMethodSender sends the DeleteConnectionMethod request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) DeleteConnectionMethodSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // DeleteConnectionMethodResponder handles the response to the DeleteConnectionMethod request. The method always
    // closes the http.Response Body.
    func (client BaseClient) DeleteConnectionMethodResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // DeleteFlowMethod sends the delete flow request.
    func (client BaseClient) DeleteFlowMethod(ctx context.Context, ID string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.DeleteFlowMethod")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.DeleteFlowMethodPreparer(ctx, ID)
        if err != nil {
        err = autorest.NewErrorWithError(err, ".BaseClient", "DeleteFlowMethod", nil , "Failure preparing request")
        return
        }

                resp, err := client.DeleteFlowMethodSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, ".BaseClient", "DeleteFlowMethod", resp, "Failure sending request")
                return
                }

                result, err = client.DeleteFlowMethodResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, ".BaseClient", "DeleteFlowMethod", resp, "Failure responding to request")
                }

        return
        }

        // DeleteFlowMethodPreparer prepares the DeleteFlowMethod request.
        func (client BaseClient) DeleteFlowMethodPreparer(ctx context.Context, ID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsDelete(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v1/flows/{id}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // DeleteFlowMethodSender sends the DeleteFlowMethod request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) DeleteFlowMethodSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // DeleteFlowMethodResponder handles the response to the DeleteFlowMethod request. The method always
    // closes the http.Response Body.
    func (client BaseClient) DeleteFlowMethodResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // DeleteJobMethod sends the delete job request.
    func (client BaseClient) DeleteJobMethod(ctx context.Context, ID string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.DeleteJobMethod")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.DeleteJobMethodPreparer(ctx, ID)
        if err != nil {
        err = autorest.NewErrorWithError(err, ".BaseClient", "DeleteJobMethod", nil , "Failure preparing request")
        return
        }

                resp, err := client.DeleteJobMethodSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, ".BaseClient", "DeleteJobMethod", resp, "Failure sending request")
                return
                }

                result, err = client.DeleteJobMethodResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, ".BaseClient", "DeleteJobMethod", resp, "Failure responding to request")
                }

        return
        }

        // DeleteJobMethodPreparer prepares the DeleteJobMethod request.
        func (client BaseClient) DeleteJobMethodPreparer(ctx context.Context, ID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsDelete(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v1/jobs/{id}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // DeleteJobMethodSender sends the DeleteJobMethod request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) DeleteJobMethodSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // DeleteJobMethodResponder handles the response to the DeleteJobMethod request. The method always
    // closes the http.Response Body.
    func (client BaseClient) DeleteJobMethodResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // DeleteSchemaMethod sends the delete schema request.
    func (client BaseClient) DeleteSchemaMethod(ctx context.Context, ID string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.DeleteSchemaMethod")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.DeleteSchemaMethodPreparer(ctx, ID)
        if err != nil {
        err = autorest.NewErrorWithError(err, ".BaseClient", "DeleteSchemaMethod", nil , "Failure preparing request")
        return
        }

                resp, err := client.DeleteSchemaMethodSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, ".BaseClient", "DeleteSchemaMethod", resp, "Failure sending request")
                return
                }

                result, err = client.DeleteSchemaMethodResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, ".BaseClient", "DeleteSchemaMethod", resp, "Failure responding to request")
                }

        return
        }

        // DeleteSchemaMethodPreparer prepares the DeleteSchemaMethod request.
        func (client BaseClient) DeleteSchemaMethodPreparer(ctx context.Context, ID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsDelete(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v1/schemas/{id}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // DeleteSchemaMethodSender sends the DeleteSchemaMethod request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) DeleteSchemaMethodSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // DeleteSchemaMethodResponder handles the response to the DeleteSchemaMethod request. The method always
    // closes the http.Response Body.
    func (client BaseClient) DeleteSchemaMethodResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // DeleteSchemaProfileMethod sends the delete schema profile request.
    func (client BaseClient) DeleteSchemaProfileMethod(ctx context.Context, ID string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.DeleteSchemaProfileMethod")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.DeleteSchemaProfileMethodPreparer(ctx, ID)
        if err != nil {
        err = autorest.NewErrorWithError(err, ".BaseClient", "DeleteSchemaProfileMethod", nil , "Failure preparing request")
        return
        }

                resp, err := client.DeleteSchemaProfileMethodSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, ".BaseClient", "DeleteSchemaProfileMethod", resp, "Failure sending request")
                return
                }

                result, err = client.DeleteSchemaProfileMethodResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, ".BaseClient", "DeleteSchemaProfileMethod", resp, "Failure responding to request")
                }

        return
        }

        // DeleteSchemaProfileMethodPreparer prepares the DeleteSchemaProfileMethod request.
        func (client BaseClient) DeleteSchemaProfileMethodPreparer(ctx context.Context, ID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsDelete(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v1/schemaprofiles/{id}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // DeleteSchemaProfileMethodSender sends the DeleteSchemaProfileMethod request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) DeleteSchemaProfileMethodSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // DeleteSchemaProfileMethodResponder handles the response to the DeleteSchemaProfileMethod request. The method always
    // closes the http.Response Body.
    func (client BaseClient) DeleteSchemaProfileMethodResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // DeleteShapeMethod sends the delete shape request.
    func (client BaseClient) DeleteShapeMethod(ctx context.Context, ID string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.DeleteShapeMethod")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.DeleteShapeMethodPreparer(ctx, ID)
        if err != nil {
        err = autorest.NewErrorWithError(err, ".BaseClient", "DeleteShapeMethod", nil , "Failure preparing request")
        return
        }

                resp, err := client.DeleteShapeMethodSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, ".BaseClient", "DeleteShapeMethod", resp, "Failure sending request")
                return
                }

                result, err = client.DeleteShapeMethodResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, ".BaseClient", "DeleteShapeMethod", resp, "Failure responding to request")
                }

        return
        }

        // DeleteShapeMethodPreparer prepares the DeleteShapeMethod request.
        func (client BaseClient) DeleteShapeMethodPreparer(ctx context.Context, ID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsDelete(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v1/shapes/{id}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // DeleteShapeMethodSender sends the DeleteShapeMethod request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) DeleteShapeMethodSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // DeleteShapeMethodResponder handles the response to the DeleteShapeMethod request. The method always
    // closes the http.Response Body.
    func (client BaseClient) DeleteShapeMethodResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // EventsPlaceholderForBatchMethod sends the events placeholder for batch request.
    func (client BaseClient) EventsPlaceholderForBatchMethod(ctx context.Context) (result DataflowEventType, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.EventsPlaceholderForBatchMethod")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.EventsPlaceholderForBatchMethodPreparer(ctx)
        if err != nil {
        err = autorest.NewErrorWithError(err, ".BaseClient", "EventsPlaceholderForBatchMethod", nil , "Failure preparing request")
        return
        }

                resp, err := client.EventsPlaceholderForBatchMethodSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, ".BaseClient", "EventsPlaceholderForBatchMethod", resp, "Failure sending request")
                return
                }

                result, err = client.EventsPlaceholderForBatchMethodResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, ".BaseClient", "EventsPlaceholderForBatchMethod", resp, "Failure responding to request")
                }

        return
        }

        // EventsPlaceholderForBatchMethodPreparer prepares the EventsPlaceholderForBatchMethod request.
        func (client BaseClient) EventsPlaceholderForBatchMethodPreparer(ctx context.Context) (*http.Request, error) {
            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v1/batches/events"))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // EventsPlaceholderForBatchMethodSender sends the EventsPlaceholderForBatchMethod request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) EventsPlaceholderForBatchMethodSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // EventsPlaceholderForBatchMethodResponder handles the response to the EventsPlaceholderForBatchMethod request. The method always
    // closes the http.Response Body.
    func (client BaseClient) EventsPlaceholderForBatchMethodResponder(resp *http.Response) (result DataflowEventType, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // EventsPlaceholderForJobMethod sends the events placeholder for job request.
    func (client BaseClient) EventsPlaceholderForJobMethod(ctx context.Context) (result DataflowEventType, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.EventsPlaceholderForJobMethod")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.EventsPlaceholderForJobMethodPreparer(ctx)
        if err != nil {
        err = autorest.NewErrorWithError(err, ".BaseClient", "EventsPlaceholderForJobMethod", nil , "Failure preparing request")
        return
        }

                resp, err := client.EventsPlaceholderForJobMethodSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, ".BaseClient", "EventsPlaceholderForJobMethod", resp, "Failure sending request")
                return
                }

                result, err = client.EventsPlaceholderForJobMethodResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, ".BaseClient", "EventsPlaceholderForJobMethod", resp, "Failure responding to request")
                }

        return
        }

        // EventsPlaceholderForJobMethodPreparer prepares the EventsPlaceholderForJobMethod request.
        func (client BaseClient) EventsPlaceholderForJobMethodPreparer(ctx context.Context) (*http.Request, error) {
            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v1/jobs/events"))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // EventsPlaceholderForJobMethodSender sends the EventsPlaceholderForJobMethod request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) EventsPlaceholderForJobMethodSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // EventsPlaceholderForJobMethodResponder handles the response to the EventsPlaceholderForJobMethod request. The method always
    // closes the http.Response Body.
    func (client BaseClient) EventsPlaceholderForJobMethodResponder(resp *http.Response) (result DataflowEventType, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetAllBatchesMethod sends the get all batches request.
    func (client BaseClient) GetAllBatchesMethod(ctx context.Context, ID string, name string, description string, jobID string, createdBy string, updatedBy string, deletedBy string) (result ListBatchType, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetAllBatchesMethod")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetAllBatchesMethodPreparer(ctx, ID, name, description, jobID, createdBy, updatedBy, deletedBy)
        if err != nil {
        err = autorest.NewErrorWithError(err, ".BaseClient", "GetAllBatchesMethod", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetAllBatchesMethodSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, ".BaseClient", "GetAllBatchesMethod", resp, "Failure sending request")
                return
                }

                result, err = client.GetAllBatchesMethodResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, ".BaseClient", "GetAllBatchesMethod", resp, "Failure responding to request")
                }

        return
        }

        // GetAllBatchesMethodPreparer prepares the GetAllBatchesMethod request.
        func (client BaseClient) GetAllBatchesMethodPreparer(ctx context.Context, ID string, name string, description string, jobID string, createdBy string, updatedBy string, deletedBy string) (*http.Request, error) {
                    queryParameters := map[string]interface{} {
            }
                if len(ID) > 0 {
                queryParameters["id"] = autorest.Encode("query",ID)
                }
                if len(name) > 0 {
                queryParameters["name"] = autorest.Encode("query",name)
                }
                if len(description) > 0 {
                queryParameters["description"] = autorest.Encode("query",description)
                }
                if len(jobID) > 0 {
                queryParameters["jobId"] = autorest.Encode("query",jobID)
                }
                if len(createdBy) > 0 {
                queryParameters["createdBy"] = autorest.Encode("query",createdBy)
                }
                if len(updatedBy) > 0 {
                queryParameters["updatedBy"] = autorest.Encode("query",updatedBy)
                }
                if len(deletedBy) > 0 {
                queryParameters["deletedBy"] = autorest.Encode("query",deletedBy)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v1/batches"),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetAllBatchesMethodSender sends the GetAllBatchesMethod request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetAllBatchesMethodSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetAllBatchesMethodResponder handles the response to the GetAllBatchesMethod request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetAllBatchesMethodResponder(resp *http.Response) (result ListBatchType, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result.Value),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetAllConnectionsMethod sends the get all connections request.
    func (client BaseClient) GetAllConnectionsMethod(ctx context.Context, ID string, name string, description string, plugin string, preferredAgent string, createdBy string, updatedBy string, deletedBy string) (result ListConnectionType, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetAllConnectionsMethod")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetAllConnectionsMethodPreparer(ctx, ID, name, description, plugin, preferredAgent, createdBy, updatedBy, deletedBy)
        if err != nil {
        err = autorest.NewErrorWithError(err, ".BaseClient", "GetAllConnectionsMethod", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetAllConnectionsMethodSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, ".BaseClient", "GetAllConnectionsMethod", resp, "Failure sending request")
                return
                }

                result, err = client.GetAllConnectionsMethodResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, ".BaseClient", "GetAllConnectionsMethod", resp, "Failure responding to request")
                }

        return
        }

        // GetAllConnectionsMethodPreparer prepares the GetAllConnectionsMethod request.
        func (client BaseClient) GetAllConnectionsMethodPreparer(ctx context.Context, ID string, name string, description string, plugin string, preferredAgent string, createdBy string, updatedBy string, deletedBy string) (*http.Request, error) {
                    queryParameters := map[string]interface{} {
            }
                if len(ID) > 0 {
                queryParameters["id"] = autorest.Encode("query",ID)
                }
                if len(name) > 0 {
                queryParameters["name"] = autorest.Encode("query",name)
                }
                if len(description) > 0 {
                queryParameters["description"] = autorest.Encode("query",description)
                }
                if len(plugin) > 0 {
                queryParameters["plugin"] = autorest.Encode("query",plugin)
                }
                if len(preferredAgent) > 0 {
                queryParameters["preferredAgent"] = autorest.Encode("query",preferredAgent)
                }
                if len(createdBy) > 0 {
                queryParameters["createdBy"] = autorest.Encode("query",createdBy)
                }
                if len(updatedBy) > 0 {
                queryParameters["updatedBy"] = autorest.Encode("query",updatedBy)
                }
                if len(deletedBy) > 0 {
                queryParameters["deletedBy"] = autorest.Encode("query",deletedBy)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v1/connections"),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetAllConnectionsMethodSender sends the GetAllConnectionsMethod request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetAllConnectionsMethodSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetAllConnectionsMethodResponder handles the response to the GetAllConnectionsMethod request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetAllConnectionsMethodResponder(resp *http.Response) (result ListConnectionType, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result.Value),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetAllFlowsMethod sends the get all flows request.
    func (client BaseClient) GetAllFlowsMethod(ctx context.Context, ID string, name string, description string, createdBy string, updatedBy string, deletedBy string) (result ListFlowType, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetAllFlowsMethod")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetAllFlowsMethodPreparer(ctx, ID, name, description, createdBy, updatedBy, deletedBy)
        if err != nil {
        err = autorest.NewErrorWithError(err, ".BaseClient", "GetAllFlowsMethod", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetAllFlowsMethodSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, ".BaseClient", "GetAllFlowsMethod", resp, "Failure sending request")
                return
                }

                result, err = client.GetAllFlowsMethodResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, ".BaseClient", "GetAllFlowsMethod", resp, "Failure responding to request")
                }

        return
        }

        // GetAllFlowsMethodPreparer prepares the GetAllFlowsMethod request.
        func (client BaseClient) GetAllFlowsMethodPreparer(ctx context.Context, ID string, name string, description string, createdBy string, updatedBy string, deletedBy string) (*http.Request, error) {
                    queryParameters := map[string]interface{} {
            }
                if len(ID) > 0 {
                queryParameters["id"] = autorest.Encode("query",ID)
                }
                if len(name) > 0 {
                queryParameters["name"] = autorest.Encode("query",name)
                }
                if len(description) > 0 {
                queryParameters["description"] = autorest.Encode("query",description)
                }
                if len(createdBy) > 0 {
                queryParameters["createdBy"] = autorest.Encode("query",createdBy)
                }
                if len(updatedBy) > 0 {
                queryParameters["updatedBy"] = autorest.Encode("query",updatedBy)
                }
                if len(deletedBy) > 0 {
                queryParameters["deletedBy"] = autorest.Encode("query",deletedBy)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v1/flows"),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetAllFlowsMethodSender sends the GetAllFlowsMethod request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetAllFlowsMethodSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetAllFlowsMethodResponder handles the response to the GetAllFlowsMethod request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetAllFlowsMethodResponder(resp *http.Response) (result ListFlowType, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result.Value),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetAllJobsMethod sends the get all jobs request.
    func (client BaseClient) GetAllJobsMethod(ctx context.Context, ID string, name string, description string, connectionID string, schemaID string, shapeID string, agentID string, typeParameter string, createdBy string, updatedBy string, deletedBy string) (result ListJobType, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetAllJobsMethod")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetAllJobsMethodPreparer(ctx, ID, name, description, connectionID, schemaID, shapeID, agentID, typeParameter, createdBy, updatedBy, deletedBy)
        if err != nil {
        err = autorest.NewErrorWithError(err, ".BaseClient", "GetAllJobsMethod", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetAllJobsMethodSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, ".BaseClient", "GetAllJobsMethod", resp, "Failure sending request")
                return
                }

                result, err = client.GetAllJobsMethodResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, ".BaseClient", "GetAllJobsMethod", resp, "Failure responding to request")
                }

        return
        }

        // GetAllJobsMethodPreparer prepares the GetAllJobsMethod request.
        func (client BaseClient) GetAllJobsMethodPreparer(ctx context.Context, ID string, name string, description string, connectionID string, schemaID string, shapeID string, agentID string, typeParameter string, createdBy string, updatedBy string, deletedBy string) (*http.Request, error) {
                    queryParameters := map[string]interface{} {
            }
                if len(ID) > 0 {
                queryParameters["id"] = autorest.Encode("query",ID)
                }
                if len(name) > 0 {
                queryParameters["name"] = autorest.Encode("query",name)
                }
                if len(description) > 0 {
                queryParameters["description"] = autorest.Encode("query",description)
                }
                if len(connectionID) > 0 {
                queryParameters["connectionId"] = autorest.Encode("query",connectionID)
                }
                if len(schemaID) > 0 {
                queryParameters["schemaId"] = autorest.Encode("query",schemaID)
                }
                if len(shapeID) > 0 {
                queryParameters["shapeId"] = autorest.Encode("query",shapeID)
                }
                if len(agentID) > 0 {
                queryParameters["agentId"] = autorest.Encode("query",agentID)
                }
                if len(typeParameter) > 0 {
                queryParameters["type"] = autorest.Encode("query",typeParameter)
                }
                if len(createdBy) > 0 {
                queryParameters["createdBy"] = autorest.Encode("query",createdBy)
                }
                if len(updatedBy) > 0 {
                queryParameters["updatedBy"] = autorest.Encode("query",updatedBy)
                }
                if len(deletedBy) > 0 {
                queryParameters["deletedBy"] = autorest.Encode("query",deletedBy)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v1/jobs"),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetAllJobsMethodSender sends the GetAllJobsMethod request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetAllJobsMethodSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetAllJobsMethodResponder handles the response to the GetAllJobsMethod request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetAllJobsMethodResponder(resp *http.Response) (result ListJobType, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result.Value),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetAllSchemaProfilesMethod sends the get all schema profiles request.
    func (client BaseClient) GetAllSchemaProfilesMethod(ctx context.Context, ID string, name string, description string, connectionID string, createdBy string, updatedBy string, deletedBy string) (result ListSchemaProfileType, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetAllSchemaProfilesMethod")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetAllSchemaProfilesMethodPreparer(ctx, ID, name, description, connectionID, createdBy, updatedBy, deletedBy)
        if err != nil {
        err = autorest.NewErrorWithError(err, ".BaseClient", "GetAllSchemaProfilesMethod", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetAllSchemaProfilesMethodSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, ".BaseClient", "GetAllSchemaProfilesMethod", resp, "Failure sending request")
                return
                }

                result, err = client.GetAllSchemaProfilesMethodResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, ".BaseClient", "GetAllSchemaProfilesMethod", resp, "Failure responding to request")
                }

        return
        }

        // GetAllSchemaProfilesMethodPreparer prepares the GetAllSchemaProfilesMethod request.
        func (client BaseClient) GetAllSchemaProfilesMethodPreparer(ctx context.Context, ID string, name string, description string, connectionID string, createdBy string, updatedBy string, deletedBy string) (*http.Request, error) {
                    queryParameters := map[string]interface{} {
            }
                if len(ID) > 0 {
                queryParameters["id"] = autorest.Encode("query",ID)
                }
                if len(name) > 0 {
                queryParameters["name"] = autorest.Encode("query",name)
                }
                if len(description) > 0 {
                queryParameters["description"] = autorest.Encode("query",description)
                }
                if len(connectionID) > 0 {
                queryParameters["connectionId"] = autorest.Encode("query",connectionID)
                }
                if len(createdBy) > 0 {
                queryParameters["createdBy"] = autorest.Encode("query",createdBy)
                }
                if len(updatedBy) > 0 {
                queryParameters["updatedBy"] = autorest.Encode("query",updatedBy)
                }
                if len(deletedBy) > 0 {
                queryParameters["deletedBy"] = autorest.Encode("query",deletedBy)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v1/schemaprofiles"),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetAllSchemaProfilesMethodSender sends the GetAllSchemaProfilesMethod request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetAllSchemaProfilesMethodSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetAllSchemaProfilesMethodResponder handles the response to the GetAllSchemaProfilesMethod request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetAllSchemaProfilesMethodResponder(resp *http.Response) (result ListSchemaProfileType, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result.Value),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetAllSchemasMethod sends the get all schemas request.
    func (client BaseClient) GetAllSchemasMethod(ctx context.Context, ID string, name string, description string, discoveredID string, discoveredName string, discoveredDescription string, query string, connectionID string, profilingJobID string, publisherMetaJSON string, capability string, createdBy string, updatedBy string, deletedBy string) (result ListSchemaType, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetAllSchemasMethod")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetAllSchemasMethodPreparer(ctx, ID, name, description, discoveredID, discoveredName, discoveredDescription, query, connectionID, profilingJobID, publisherMetaJSON, capability, createdBy, updatedBy, deletedBy)
        if err != nil {
        err = autorest.NewErrorWithError(err, ".BaseClient", "GetAllSchemasMethod", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetAllSchemasMethodSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, ".BaseClient", "GetAllSchemasMethod", resp, "Failure sending request")
                return
                }

                result, err = client.GetAllSchemasMethodResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, ".BaseClient", "GetAllSchemasMethod", resp, "Failure responding to request")
                }

        return
        }

        // GetAllSchemasMethodPreparer prepares the GetAllSchemasMethod request.
        func (client BaseClient) GetAllSchemasMethodPreparer(ctx context.Context, ID string, name string, description string, discoveredID string, discoveredName string, discoveredDescription string, query string, connectionID string, profilingJobID string, publisherMetaJSON string, capability string, createdBy string, updatedBy string, deletedBy string) (*http.Request, error) {
                    queryParameters := map[string]interface{} {
            }
                if len(ID) > 0 {
                queryParameters["id"] = autorest.Encode("query",ID)
                }
                if len(name) > 0 {
                queryParameters["name"] = autorest.Encode("query",name)
                }
                if len(description) > 0 {
                queryParameters["description"] = autorest.Encode("query",description)
                }
                if len(discoveredID) > 0 {
                queryParameters["discoveredId"] = autorest.Encode("query",discoveredID)
                }
                if len(discoveredName) > 0 {
                queryParameters["discoveredName"] = autorest.Encode("query",discoveredName)
                }
                if len(discoveredDescription) > 0 {
                queryParameters["discoveredDescription"] = autorest.Encode("query",discoveredDescription)
                }
                if len(query) > 0 {
                queryParameters["query"] = autorest.Encode("query",query)
                }
                if len(connectionID) > 0 {
                queryParameters["connectionId"] = autorest.Encode("query",connectionID)
                }
                if len(profilingJobID) > 0 {
                queryParameters["profilingJobId"] = autorest.Encode("query",profilingJobID)
                }
                if len(publisherMetaJSON) > 0 {
                queryParameters["publisherMetaJson"] = autorest.Encode("query",publisherMetaJSON)
                }
                if len(capability) > 0 {
                queryParameters["capability"] = autorest.Encode("query",capability)
                }
                if len(createdBy) > 0 {
                queryParameters["createdBy"] = autorest.Encode("query",createdBy)
                }
                if len(updatedBy) > 0 {
                queryParameters["updatedBy"] = autorest.Encode("query",updatedBy)
                }
                if len(deletedBy) > 0 {
                queryParameters["deletedBy"] = autorest.Encode("query",deletedBy)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v1/schemas"),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetAllSchemasMethodSender sends the GetAllSchemasMethod request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetAllSchemasMethodSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetAllSchemasMethodResponder handles the response to the GetAllSchemasMethod request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetAllSchemasMethodResponder(resp *http.Response) (result ListSchemaType, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result.Value),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetAllShapesMethod sends the get all shapes request.
    func (client BaseClient) GetAllShapesMethod(ctx context.Context, ID string, name string, description string, copiedFromSchemaID string, createdBy string, updatedBy string, deletedBy string) (result ListShapeType, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetAllShapesMethod")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetAllShapesMethodPreparer(ctx, ID, name, description, copiedFromSchemaID, createdBy, updatedBy, deletedBy)
        if err != nil {
        err = autorest.NewErrorWithError(err, ".BaseClient", "GetAllShapesMethod", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetAllShapesMethodSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, ".BaseClient", "GetAllShapesMethod", resp, "Failure sending request")
                return
                }

                result, err = client.GetAllShapesMethodResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, ".BaseClient", "GetAllShapesMethod", resp, "Failure responding to request")
                }

        return
        }

        // GetAllShapesMethodPreparer prepares the GetAllShapesMethod request.
        func (client BaseClient) GetAllShapesMethodPreparer(ctx context.Context, ID string, name string, description string, copiedFromSchemaID string, createdBy string, updatedBy string, deletedBy string) (*http.Request, error) {
                    queryParameters := map[string]interface{} {
            }
                if len(ID) > 0 {
                queryParameters["id"] = autorest.Encode("query",ID)
                }
                if len(name) > 0 {
                queryParameters["name"] = autorest.Encode("query",name)
                }
                if len(description) > 0 {
                queryParameters["description"] = autorest.Encode("query",description)
                }
                if len(copiedFromSchemaID) > 0 {
                queryParameters["copiedFromSchemaId"] = autorest.Encode("query",copiedFromSchemaID)
                }
                if len(createdBy) > 0 {
                queryParameters["createdBy"] = autorest.Encode("query",createdBy)
                }
                if len(updatedBy) > 0 {
                queryParameters["updatedBy"] = autorest.Encode("query",updatedBy)
                }
                if len(deletedBy) > 0 {
                queryParameters["deletedBy"] = autorest.Encode("query",deletedBy)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v1/shapes"),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetAllShapesMethodSender sends the GetAllShapesMethod request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetAllShapesMethodSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetAllShapesMethodResponder handles the response to the GetAllShapesMethod request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetAllShapesMethodResponder(resp *http.Response) (result ListShapeType, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result.Value),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetBatchVersionsMethod sends the get batch versions request.
    func (client BaseClient) GetBatchVersionsMethod(ctx context.Context, ID string) (result ListBatchType, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetBatchVersionsMethod")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetBatchVersionsMethodPreparer(ctx, ID)
        if err != nil {
        err = autorest.NewErrorWithError(err, ".BaseClient", "GetBatchVersionsMethod", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetBatchVersionsMethodSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, ".BaseClient", "GetBatchVersionsMethod", resp, "Failure sending request")
                return
                }

                result, err = client.GetBatchVersionsMethodResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, ".BaseClient", "GetBatchVersionsMethod", resp, "Failure responding to request")
                }

        return
        }

        // GetBatchVersionsMethodPreparer prepares the GetBatchVersionsMethod request.
        func (client BaseClient) GetBatchVersionsMethodPreparer(ctx context.Context, ID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v1/batches/{id}/versions",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetBatchVersionsMethodSender sends the GetBatchVersionsMethod request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetBatchVersionsMethodSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetBatchVersionsMethodResponder handles the response to the GetBatchVersionsMethod request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetBatchVersionsMethodResponder(resp *http.Response) (result ListBatchType, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result.Value),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetConnectionVersionsMethod sends the get connection versions request.
    func (client BaseClient) GetConnectionVersionsMethod(ctx context.Context, ID string) (result ListConnectionType, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetConnectionVersionsMethod")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetConnectionVersionsMethodPreparer(ctx, ID)
        if err != nil {
        err = autorest.NewErrorWithError(err, ".BaseClient", "GetConnectionVersionsMethod", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetConnectionVersionsMethodSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, ".BaseClient", "GetConnectionVersionsMethod", resp, "Failure sending request")
                return
                }

                result, err = client.GetConnectionVersionsMethodResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, ".BaseClient", "GetConnectionVersionsMethod", resp, "Failure responding to request")
                }

        return
        }

        // GetConnectionVersionsMethodPreparer prepares the GetConnectionVersionsMethod request.
        func (client BaseClient) GetConnectionVersionsMethodPreparer(ctx context.Context, ID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v1/connections/{id}/versions",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetConnectionVersionsMethodSender sends the GetConnectionVersionsMethod request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetConnectionVersionsMethodSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetConnectionVersionsMethodResponder handles the response to the GetConnectionVersionsMethod request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetConnectionVersionsMethodResponder(resp *http.Response) (result ListConnectionType, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result.Value),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetFlowVersionsMethod sends the get flow versions request.
    func (client BaseClient) GetFlowVersionsMethod(ctx context.Context, ID string) (result ListFlowType, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetFlowVersionsMethod")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetFlowVersionsMethodPreparer(ctx, ID)
        if err != nil {
        err = autorest.NewErrorWithError(err, ".BaseClient", "GetFlowVersionsMethod", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetFlowVersionsMethodSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, ".BaseClient", "GetFlowVersionsMethod", resp, "Failure sending request")
                return
                }

                result, err = client.GetFlowVersionsMethodResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, ".BaseClient", "GetFlowVersionsMethod", resp, "Failure responding to request")
                }

        return
        }

        // GetFlowVersionsMethodPreparer prepares the GetFlowVersionsMethod request.
        func (client BaseClient) GetFlowVersionsMethodPreparer(ctx context.Context, ID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v1/flows/{id}/versions",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetFlowVersionsMethodSender sends the GetFlowVersionsMethod request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetFlowVersionsMethodSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetFlowVersionsMethodResponder handles the response to the GetFlowVersionsMethod request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetFlowVersionsMethodResponder(resp *http.Response) (result ListFlowType, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result.Value),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetJobMappingMethod sends the get job mapping request.
    func (client BaseClient) GetJobMappingMethod(ctx context.Context, ID string, version *int32) (result MappingType, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetJobMappingMethod")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetJobMappingMethodPreparer(ctx, ID, version)
        if err != nil {
        err = autorest.NewErrorWithError(err, ".BaseClient", "GetJobMappingMethod", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetJobMappingMethodSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, ".BaseClient", "GetJobMappingMethod", resp, "Failure sending request")
                return
                }

                result, err = client.GetJobMappingMethodResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, ".BaseClient", "GetJobMappingMethod", resp, "Failure responding to request")
                }

        return
        }

        // GetJobMappingMethodPreparer prepares the GetJobMappingMethod request.
        func (client BaseClient) GetJobMappingMethodPreparer(ctx context.Context, ID string, version *int32) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

                        queryParameters := map[string]interface{} {
            }
                if version != nil {
                queryParameters["version"] = autorest.Encode("query",*version)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v1/jobs/{id}/mapping",pathParameters),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetJobMappingMethodSender sends the GetJobMappingMethod request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetJobMappingMethodSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetJobMappingMethodResponder handles the response to the GetJobMappingMethod request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetJobMappingMethodResponder(resp *http.Response) (result MappingType, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetJobVersionsMethod sends the get job versions request.
    func (client BaseClient) GetJobVersionsMethod(ctx context.Context, ID string) (result ListJobType, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetJobVersionsMethod")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetJobVersionsMethodPreparer(ctx, ID)
        if err != nil {
        err = autorest.NewErrorWithError(err, ".BaseClient", "GetJobVersionsMethod", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetJobVersionsMethodSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, ".BaseClient", "GetJobVersionsMethod", resp, "Failure sending request")
                return
                }

                result, err = client.GetJobVersionsMethodResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, ".BaseClient", "GetJobVersionsMethod", resp, "Failure responding to request")
                }

        return
        }

        // GetJobVersionsMethodPreparer prepares the GetJobVersionsMethod request.
        func (client BaseClient) GetJobVersionsMethodPreparer(ctx context.Context, ID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v1/jobs/{id}/versions",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetJobVersionsMethodSender sends the GetJobVersionsMethod request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetJobVersionsMethodSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetJobVersionsMethodResponder handles the response to the GetJobVersionsMethod request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetJobVersionsMethodResponder(resp *http.Response) (result ListJobType, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result.Value),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetOneBatchMethod sends the get one batch request.
    func (client BaseClient) GetOneBatchMethod(ctx context.Context, ID string, version *int32) (result BatchType, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetOneBatchMethod")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetOneBatchMethodPreparer(ctx, ID, version)
        if err != nil {
        err = autorest.NewErrorWithError(err, ".BaseClient", "GetOneBatchMethod", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetOneBatchMethodSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, ".BaseClient", "GetOneBatchMethod", resp, "Failure sending request")
                return
                }

                result, err = client.GetOneBatchMethodResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, ".BaseClient", "GetOneBatchMethod", resp, "Failure responding to request")
                }

        return
        }

        // GetOneBatchMethodPreparer prepares the GetOneBatchMethod request.
        func (client BaseClient) GetOneBatchMethodPreparer(ctx context.Context, ID string, version *int32) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

                        queryParameters := map[string]interface{} {
            }
                if version != nil {
                queryParameters["version"] = autorest.Encode("query",*version)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v1/batches/{id}",pathParameters),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetOneBatchMethodSender sends the GetOneBatchMethod request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetOneBatchMethodSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetOneBatchMethodResponder handles the response to the GetOneBatchMethod request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetOneBatchMethodResponder(resp *http.Response) (result BatchType, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetOneConnectionMethod sends the get one connection request.
    func (client BaseClient) GetOneConnectionMethod(ctx context.Context, ID string, version *int32) (result ConnectionType, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetOneConnectionMethod")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetOneConnectionMethodPreparer(ctx, ID, version)
        if err != nil {
        err = autorest.NewErrorWithError(err, ".BaseClient", "GetOneConnectionMethod", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetOneConnectionMethodSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, ".BaseClient", "GetOneConnectionMethod", resp, "Failure sending request")
                return
                }

                result, err = client.GetOneConnectionMethodResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, ".BaseClient", "GetOneConnectionMethod", resp, "Failure responding to request")
                }

        return
        }

        // GetOneConnectionMethodPreparer prepares the GetOneConnectionMethod request.
        func (client BaseClient) GetOneConnectionMethodPreparer(ctx context.Context, ID string, version *int32) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

                        queryParameters := map[string]interface{} {
            }
                if version != nil {
                queryParameters["version"] = autorest.Encode("query",*version)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v1/connections/{id}",pathParameters),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetOneConnectionMethodSender sends the GetOneConnectionMethod request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetOneConnectionMethodSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetOneConnectionMethodResponder handles the response to the GetOneConnectionMethod request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetOneConnectionMethodResponder(resp *http.Response) (result ConnectionType, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetOneFlowMethod sends the get one flow request.
    func (client BaseClient) GetOneFlowMethod(ctx context.Context, ID string, version *int32) (result FlowType, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetOneFlowMethod")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetOneFlowMethodPreparer(ctx, ID, version)
        if err != nil {
        err = autorest.NewErrorWithError(err, ".BaseClient", "GetOneFlowMethod", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetOneFlowMethodSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, ".BaseClient", "GetOneFlowMethod", resp, "Failure sending request")
                return
                }

                result, err = client.GetOneFlowMethodResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, ".BaseClient", "GetOneFlowMethod", resp, "Failure responding to request")
                }

        return
        }

        // GetOneFlowMethodPreparer prepares the GetOneFlowMethod request.
        func (client BaseClient) GetOneFlowMethodPreparer(ctx context.Context, ID string, version *int32) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

                        queryParameters := map[string]interface{} {
            }
                if version != nil {
                queryParameters["version"] = autorest.Encode("query",*version)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v1/flows/{id}",pathParameters),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetOneFlowMethodSender sends the GetOneFlowMethod request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetOneFlowMethodSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetOneFlowMethodResponder handles the response to the GetOneFlowMethod request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetOneFlowMethodResponder(resp *http.Response) (result FlowType, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetOneJobMethod sends the get one job request.
    func (client BaseClient) GetOneJobMethod(ctx context.Context, ID string, version *int32) (result JobType, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetOneJobMethod")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetOneJobMethodPreparer(ctx, ID, version)
        if err != nil {
        err = autorest.NewErrorWithError(err, ".BaseClient", "GetOneJobMethod", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetOneJobMethodSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, ".BaseClient", "GetOneJobMethod", resp, "Failure sending request")
                return
                }

                result, err = client.GetOneJobMethodResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, ".BaseClient", "GetOneJobMethod", resp, "Failure responding to request")
                }

        return
        }

        // GetOneJobMethodPreparer prepares the GetOneJobMethod request.
        func (client BaseClient) GetOneJobMethodPreparer(ctx context.Context, ID string, version *int32) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

                        queryParameters := map[string]interface{} {
            }
                if version != nil {
                queryParameters["version"] = autorest.Encode("query",*version)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v1/jobs/{id}",pathParameters),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetOneJobMethodSender sends the GetOneJobMethod request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetOneJobMethodSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetOneJobMethodResponder handles the response to the GetOneJobMethod request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetOneJobMethodResponder(resp *http.Response) (result JobType, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetOneSchemaMethod sends the get one schema request.
    func (client BaseClient) GetOneSchemaMethod(ctx context.Context, ID string, version *int32) (result SchemaType, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetOneSchemaMethod")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetOneSchemaMethodPreparer(ctx, ID, version)
        if err != nil {
        err = autorest.NewErrorWithError(err, ".BaseClient", "GetOneSchemaMethod", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetOneSchemaMethodSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, ".BaseClient", "GetOneSchemaMethod", resp, "Failure sending request")
                return
                }

                result, err = client.GetOneSchemaMethodResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, ".BaseClient", "GetOneSchemaMethod", resp, "Failure responding to request")
                }

        return
        }

        // GetOneSchemaMethodPreparer prepares the GetOneSchemaMethod request.
        func (client BaseClient) GetOneSchemaMethodPreparer(ctx context.Context, ID string, version *int32) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

                        queryParameters := map[string]interface{} {
            }
                if version != nil {
                queryParameters["version"] = autorest.Encode("query",*version)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v1/schemas/{id}",pathParameters),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetOneSchemaMethodSender sends the GetOneSchemaMethod request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetOneSchemaMethodSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetOneSchemaMethodResponder handles the response to the GetOneSchemaMethod request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetOneSchemaMethodResponder(resp *http.Response) (result SchemaType, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetOneSchemaProfileMethod sends the get one schema profile request.
    func (client BaseClient) GetOneSchemaProfileMethod(ctx context.Context, ID string, version *int32) (result SchemaProfileType, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetOneSchemaProfileMethod")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetOneSchemaProfileMethodPreparer(ctx, ID, version)
        if err != nil {
        err = autorest.NewErrorWithError(err, ".BaseClient", "GetOneSchemaProfileMethod", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetOneSchemaProfileMethodSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, ".BaseClient", "GetOneSchemaProfileMethod", resp, "Failure sending request")
                return
                }

                result, err = client.GetOneSchemaProfileMethodResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, ".BaseClient", "GetOneSchemaProfileMethod", resp, "Failure responding to request")
                }

        return
        }

        // GetOneSchemaProfileMethodPreparer prepares the GetOneSchemaProfileMethod request.
        func (client BaseClient) GetOneSchemaProfileMethodPreparer(ctx context.Context, ID string, version *int32) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

                        queryParameters := map[string]interface{} {
            }
                if version != nil {
                queryParameters["version"] = autorest.Encode("query",*version)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v1/schemaprofiles/{id}",pathParameters),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetOneSchemaProfileMethodSender sends the GetOneSchemaProfileMethod request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetOneSchemaProfileMethodSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetOneSchemaProfileMethodResponder handles the response to the GetOneSchemaProfileMethod request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetOneSchemaProfileMethodResponder(resp *http.Response) (result SchemaProfileType, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetOneShapeMethod sends the get one shape request.
    func (client BaseClient) GetOneShapeMethod(ctx context.Context, ID string, version *int32) (result ShapeType, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetOneShapeMethod")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetOneShapeMethodPreparer(ctx, ID, version)
        if err != nil {
        err = autorest.NewErrorWithError(err, ".BaseClient", "GetOneShapeMethod", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetOneShapeMethodSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, ".BaseClient", "GetOneShapeMethod", resp, "Failure sending request")
                return
                }

                result, err = client.GetOneShapeMethodResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, ".BaseClient", "GetOneShapeMethod", resp, "Failure responding to request")
                }

        return
        }

        // GetOneShapeMethodPreparer prepares the GetOneShapeMethod request.
        func (client BaseClient) GetOneShapeMethodPreparer(ctx context.Context, ID string, version *int32) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

                        queryParameters := map[string]interface{} {
            }
                if version != nil {
                queryParameters["version"] = autorest.Encode("query",*version)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v1/shapes/{id}",pathParameters),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetOneShapeMethodSender sends the GetOneShapeMethod request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetOneShapeMethodSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetOneShapeMethodResponder handles the response to the GetOneShapeMethod request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetOneShapeMethodResponder(resp *http.Response) (result ShapeType, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetPagedStatusesForBatchMethod sends the get paged statuses for batch request.
    func (client BaseClient) GetPagedStatusesForBatchMethod(ctx context.Context, ID string, page *int32, pageSize *int32) (result PagedResultOfBatchStatusType, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetPagedStatusesForBatchMethod")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetPagedStatusesForBatchMethodPreparer(ctx, ID, page, pageSize)
        if err != nil {
        err = autorest.NewErrorWithError(err, ".BaseClient", "GetPagedStatusesForBatchMethod", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetPagedStatusesForBatchMethodSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, ".BaseClient", "GetPagedStatusesForBatchMethod", resp, "Failure sending request")
                return
                }

                result, err = client.GetPagedStatusesForBatchMethodResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, ".BaseClient", "GetPagedStatusesForBatchMethod", resp, "Failure responding to request")
                }

        return
        }

        // GetPagedStatusesForBatchMethodPreparer prepares the GetPagedStatusesForBatchMethod request.
        func (client BaseClient) GetPagedStatusesForBatchMethodPreparer(ctx context.Context, ID string, page *int32, pageSize *int32) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

                        queryParameters := map[string]interface{} {
            }
                if page != nil {
                queryParameters["page"] = autorest.Encode("query",*page)
                }
                if pageSize != nil {
                queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v1/batches/{id}/status",pathParameters),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetPagedStatusesForBatchMethodSender sends the GetPagedStatusesForBatchMethod request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetPagedStatusesForBatchMethodSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetPagedStatusesForBatchMethodResponder handles the response to the GetPagedStatusesForBatchMethod request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetPagedStatusesForBatchMethodResponder(resp *http.Response) (result PagedResultOfBatchStatusType, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetPagedStatusesForJobMethod sends the get paged statuses for job request.
    func (client BaseClient) GetPagedStatusesForJobMethod(ctx context.Context, ID string, page *int32, pageSize *int32) (result PagedResultOfJobStatusType, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetPagedStatusesForJobMethod")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetPagedStatusesForJobMethodPreparer(ctx, ID, page, pageSize)
        if err != nil {
        err = autorest.NewErrorWithError(err, ".BaseClient", "GetPagedStatusesForJobMethod", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetPagedStatusesForJobMethodSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, ".BaseClient", "GetPagedStatusesForJobMethod", resp, "Failure sending request")
                return
                }

                result, err = client.GetPagedStatusesForJobMethodResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, ".BaseClient", "GetPagedStatusesForJobMethod", resp, "Failure responding to request")
                }

        return
        }

        // GetPagedStatusesForJobMethodPreparer prepares the GetPagedStatusesForJobMethod request.
        func (client BaseClient) GetPagedStatusesForJobMethodPreparer(ctx context.Context, ID string, page *int32, pageSize *int32) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

                        queryParameters := map[string]interface{} {
            }
                if page != nil {
                queryParameters["page"] = autorest.Encode("query",*page)
                }
                if pageSize != nil {
                queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v1/jobs/{id}/status",pathParameters),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetPagedStatusesForJobMethodSender sends the GetPagedStatusesForJobMethod request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetPagedStatusesForJobMethodSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetPagedStatusesForJobMethodResponder handles the response to the GetPagedStatusesForJobMethod request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetPagedStatusesForJobMethodResponder(resp *http.Response) (result PagedResultOfJobStatusType, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetSchemaProfileVersionsMethod sends the get schema profile versions request.
    func (client BaseClient) GetSchemaProfileVersionsMethod(ctx context.Context, ID string) (result ListSchemaProfileType, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetSchemaProfileVersionsMethod")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetSchemaProfileVersionsMethodPreparer(ctx, ID)
        if err != nil {
        err = autorest.NewErrorWithError(err, ".BaseClient", "GetSchemaProfileVersionsMethod", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetSchemaProfileVersionsMethodSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, ".BaseClient", "GetSchemaProfileVersionsMethod", resp, "Failure sending request")
                return
                }

                result, err = client.GetSchemaProfileVersionsMethodResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, ".BaseClient", "GetSchemaProfileVersionsMethod", resp, "Failure responding to request")
                }

        return
        }

        // GetSchemaProfileVersionsMethodPreparer prepares the GetSchemaProfileVersionsMethod request.
        func (client BaseClient) GetSchemaProfileVersionsMethodPreparer(ctx context.Context, ID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v1/schemaprofiles/{id}/versions",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetSchemaProfileVersionsMethodSender sends the GetSchemaProfileVersionsMethod request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetSchemaProfileVersionsMethodSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetSchemaProfileVersionsMethodResponder handles the response to the GetSchemaProfileVersionsMethod request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetSchemaProfileVersionsMethodResponder(resp *http.Response) (result ListSchemaProfileType, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result.Value),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetSchemaVersionsMethod sends the get schema versions request.
    func (client BaseClient) GetSchemaVersionsMethod(ctx context.Context, ID string) (result ListSchemaType, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetSchemaVersionsMethod")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetSchemaVersionsMethodPreparer(ctx, ID)
        if err != nil {
        err = autorest.NewErrorWithError(err, ".BaseClient", "GetSchemaVersionsMethod", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetSchemaVersionsMethodSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, ".BaseClient", "GetSchemaVersionsMethod", resp, "Failure sending request")
                return
                }

                result, err = client.GetSchemaVersionsMethodResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, ".BaseClient", "GetSchemaVersionsMethod", resp, "Failure responding to request")
                }

        return
        }

        // GetSchemaVersionsMethodPreparer prepares the GetSchemaVersionsMethod request.
        func (client BaseClient) GetSchemaVersionsMethodPreparer(ctx context.Context, ID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v1/schemas/{id}/versions",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetSchemaVersionsMethodSender sends the GetSchemaVersionsMethod request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetSchemaVersionsMethodSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetSchemaVersionsMethodResponder handles the response to the GetSchemaVersionsMethod request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetSchemaVersionsMethodResponder(resp *http.Response) (result ListSchemaType, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result.Value),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetShapeVersionsMethod sends the get shape versions request.
    func (client BaseClient) GetShapeVersionsMethod(ctx context.Context, ID string) (result ListShapeType, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetShapeVersionsMethod")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetShapeVersionsMethodPreparer(ctx, ID)
        if err != nil {
        err = autorest.NewErrorWithError(err, ".BaseClient", "GetShapeVersionsMethod", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetShapeVersionsMethodSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, ".BaseClient", "GetShapeVersionsMethod", resp, "Failure sending request")
                return
                }

                result, err = client.GetShapeVersionsMethodResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, ".BaseClient", "GetShapeVersionsMethod", resp, "Failure responding to request")
                }

        return
        }

        // GetShapeVersionsMethodPreparer prepares the GetShapeVersionsMethod request.
        func (client BaseClient) GetShapeVersionsMethodPreparer(ctx context.Context, ID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v1/shapes/{id}/versions",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetShapeVersionsMethodSender sends the GetShapeVersionsMethod request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetShapeVersionsMethodSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetShapeVersionsMethodResponder handles the response to the GetShapeVersionsMethod request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetShapeVersionsMethodResponder(resp *http.Response) (result ListShapeType, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result.Value),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // SetBatchStatusForGoBetweenBatchMethod sends the set batch status for go between batch request.
    func (client BaseClient) SetBatchStatusForGoBetweenBatchMethod(ctx context.Context, ID string, status BatchStatusGoBetweenScopeType) (result SetListStringType, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.SetBatchStatusForGoBetweenBatchMethod")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.SetBatchStatusForGoBetweenBatchMethodPreparer(ctx, ID, status)
        if err != nil {
        err = autorest.NewErrorWithError(err, ".BaseClient", "SetBatchStatusForGoBetweenBatchMethod", nil , "Failure preparing request")
        return
        }

                resp, err := client.SetBatchStatusForGoBetweenBatchMethodSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, ".BaseClient", "SetBatchStatusForGoBetweenBatchMethod", resp, "Failure sending request")
                return
                }

                result, err = client.SetBatchStatusForGoBetweenBatchMethodResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, ".BaseClient", "SetBatchStatusForGoBetweenBatchMethod", resp, "Failure responding to request")
                }

        return
        }

        // SetBatchStatusForGoBetweenBatchMethodPreparer prepares the SetBatchStatusForGoBetweenBatchMethod request.
        func (client BaseClient) SetBatchStatusForGoBetweenBatchMethodPreparer(ctx context.Context, ID string, status BatchStatusGoBetweenScopeType) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPut(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v1/batches/{id}/status/go-between-agent",pathParameters),
        autorest.WithJSON(status))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // SetBatchStatusForGoBetweenBatchMethodSender sends the SetBatchStatusForGoBetweenBatchMethod request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) SetBatchStatusForGoBetweenBatchMethodSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // SetBatchStatusForGoBetweenBatchMethodResponder handles the response to the SetBatchStatusForGoBetweenBatchMethod request. The method always
    // closes the http.Response Body.
    func (client BaseClient) SetBatchStatusForGoBetweenBatchMethodResponder(resp *http.Response) (result SetListStringType, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusAccepted,http.StatusBadRequest),
        autorest.ByUnmarshallingJSON(&result.Value),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // SetJobStatusForGoBetweenMethod sends the set job status for go between request.
    func (client BaseClient) SetJobStatusForGoBetweenMethod(ctx context.Context, ID string, status JobStatusGoBetweenScopeType) (result SetListStringType, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.SetJobStatusForGoBetweenMethod")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.SetJobStatusForGoBetweenMethodPreparer(ctx, ID, status)
        if err != nil {
        err = autorest.NewErrorWithError(err, ".BaseClient", "SetJobStatusForGoBetweenMethod", nil , "Failure preparing request")
        return
        }

                resp, err := client.SetJobStatusForGoBetweenMethodSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, ".BaseClient", "SetJobStatusForGoBetweenMethod", resp, "Failure sending request")
                return
                }

                result, err = client.SetJobStatusForGoBetweenMethodResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, ".BaseClient", "SetJobStatusForGoBetweenMethod", resp, "Failure responding to request")
                }

        return
        }

        // SetJobStatusForGoBetweenMethodPreparer prepares the SetJobStatusForGoBetweenMethod request.
        func (client BaseClient) SetJobStatusForGoBetweenMethodPreparer(ctx context.Context, ID string, status JobStatusGoBetweenScopeType) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPut(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v1/jobs/{id}/status/go-between",pathParameters),
        autorest.WithJSON(status))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // SetJobStatusForGoBetweenMethodSender sends the SetJobStatusForGoBetweenMethod request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) SetJobStatusForGoBetweenMethodSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // SetJobStatusForGoBetweenMethodResponder handles the response to the SetJobStatusForGoBetweenMethod request. The method always
    // closes the http.Response Body.
    func (client BaseClient) SetJobStatusForGoBetweenMethodResponder(resp *http.Response) (result SetListStringType, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusAccepted,http.StatusBadRequest),
        autorest.ByUnmarshallingJSON(&result.Value),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // SetRealTimeStateMethod sends the set real time state request.
    func (client BaseClient) SetRealTimeStateMethod(ctx context.Context, ID string, state RealTimeStateScopeType) (result SetListStringType, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.SetRealTimeStateMethod")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.SetRealTimeStateMethodPreparer(ctx, ID, state)
        if err != nil {
        err = autorest.NewErrorWithError(err, ".BaseClient", "SetRealTimeStateMethod", nil , "Failure preparing request")
        return
        }

                resp, err := client.SetRealTimeStateMethodSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, ".BaseClient", "SetRealTimeStateMethod", resp, "Failure sending request")
                return
                }

                result, err = client.SetRealTimeStateMethodResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, ".BaseClient", "SetRealTimeStateMethod", resp, "Failure responding to request")
                }

        return
        }

        // SetRealTimeStateMethodPreparer prepares the SetRealTimeStateMethod request.
        func (client BaseClient) SetRealTimeStateMethodPreparer(ctx context.Context, ID string, state RealTimeStateScopeType) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPut(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v1/jobs/{id}/status/realtime",pathParameters),
        autorest.WithJSON(state))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // SetRealTimeStateMethodSender sends the SetRealTimeStateMethod request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) SetRealTimeStateMethodSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // SetRealTimeStateMethodResponder handles the response to the SetRealTimeStateMethod request. The method always
    // closes the http.Response Body.
    func (client BaseClient) SetRealTimeStateMethodResponder(resp *http.Response) (result SetListStringType, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusAccepted,http.StatusBadRequest),
        autorest.ByUnmarshallingJSON(&result.Value),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // UpdateBatchMethod sends the update batch request.
    func (client BaseClient) UpdateBatchMethod(ctx context.Context, ID string, model BatchType) (result SetObjectType, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.UpdateBatchMethod")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                if err := validation.Validate([]validation.Validation{
                { TargetValue: model,
                 Constraints: []validation.Constraint{	{Target: "model.Name", Name: validation.Null, Rule: true, Chain: nil },
                	{Target: "model.JobID", Name: validation.Null, Rule: true, Chain: nil }}}}); err != nil {
                return result, validation.NewError(".BaseClient", "UpdateBatchMethod", err.Error())
                }

                    req, err := client.UpdateBatchMethodPreparer(ctx, ID, model)
        if err != nil {
        err = autorest.NewErrorWithError(err, ".BaseClient", "UpdateBatchMethod", nil , "Failure preparing request")
        return
        }

                resp, err := client.UpdateBatchMethodSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, ".BaseClient", "UpdateBatchMethod", resp, "Failure sending request")
                return
                }

                result, err = client.UpdateBatchMethodResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, ".BaseClient", "UpdateBatchMethod", resp, "Failure responding to request")
                }

        return
        }

        // UpdateBatchMethodPreparer prepares the UpdateBatchMethod request.
        func (client BaseClient) UpdateBatchMethodPreparer(ctx context.Context, ID string, model BatchType) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPut(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v1/batches/{id}",pathParameters),
        autorest.WithJSON(model))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // UpdateBatchMethodSender sends the UpdateBatchMethod request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) UpdateBatchMethodSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // UpdateBatchMethodResponder handles the response to the UpdateBatchMethod request. The method always
    // closes the http.Response Body.
    func (client BaseClient) UpdateBatchMethodResponder(resp *http.Response) (result SetObjectType, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusAccepted,http.StatusBadRequest,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result.Value),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // UpdateConnectionMethod sends the update connection request.
    func (client BaseClient) UpdateConnectionMethod(ctx context.Context, ID string, model ConnectionType) (result SetObjectType, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.UpdateConnectionMethod")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                if err := validation.Validate([]validation.Validation{
                { TargetValue: model,
                 Constraints: []validation.Constraint{	{Target: "model.Name", Name: validation.Null, Rule: true, Chain: nil },
                	{Target: "model.Plugin", Name: validation.Null, Rule: true, Chain: nil }}}}); err != nil {
                return result, validation.NewError(".BaseClient", "UpdateConnectionMethod", err.Error())
                }

                    req, err := client.UpdateConnectionMethodPreparer(ctx, ID, model)
        if err != nil {
        err = autorest.NewErrorWithError(err, ".BaseClient", "UpdateConnectionMethod", nil , "Failure preparing request")
        return
        }

                resp, err := client.UpdateConnectionMethodSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, ".BaseClient", "UpdateConnectionMethod", resp, "Failure sending request")
                return
                }

                result, err = client.UpdateConnectionMethodResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, ".BaseClient", "UpdateConnectionMethod", resp, "Failure responding to request")
                }

        return
        }

        // UpdateConnectionMethodPreparer prepares the UpdateConnectionMethod request.
        func (client BaseClient) UpdateConnectionMethodPreparer(ctx context.Context, ID string, model ConnectionType) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPut(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v1/connections/{id}",pathParameters),
        autorest.WithJSON(model))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // UpdateConnectionMethodSender sends the UpdateConnectionMethod request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) UpdateConnectionMethodSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // UpdateConnectionMethodResponder handles the response to the UpdateConnectionMethod request. The method always
    // closes the http.Response Body.
    func (client BaseClient) UpdateConnectionMethodResponder(resp *http.Response) (result SetObjectType, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusAccepted,http.StatusBadRequest,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result.Value),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // UpdateFlowMethod sends the update flow request.
    func (client BaseClient) UpdateFlowMethod(ctx context.Context, ID string, model FlowType) (result SetObjectType, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.UpdateFlowMethod")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                if err := validation.Validate([]validation.Validation{
                { TargetValue: model,
                 Constraints: []validation.Constraint{	{Target: "model.Name", Name: validation.Null, Rule: true, Chain: nil }}}}); err != nil {
                return result, validation.NewError(".BaseClient", "UpdateFlowMethod", err.Error())
                }

                    req, err := client.UpdateFlowMethodPreparer(ctx, ID, model)
        if err != nil {
        err = autorest.NewErrorWithError(err, ".BaseClient", "UpdateFlowMethod", nil , "Failure preparing request")
        return
        }

                resp, err := client.UpdateFlowMethodSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, ".BaseClient", "UpdateFlowMethod", resp, "Failure sending request")
                return
                }

                result, err = client.UpdateFlowMethodResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, ".BaseClient", "UpdateFlowMethod", resp, "Failure responding to request")
                }

        return
        }

        // UpdateFlowMethodPreparer prepares the UpdateFlowMethod request.
        func (client BaseClient) UpdateFlowMethodPreparer(ctx context.Context, ID string, model FlowType) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPut(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v1/flows/{id}",pathParameters),
        autorest.WithJSON(model))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // UpdateFlowMethodSender sends the UpdateFlowMethod request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) UpdateFlowMethodSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // UpdateFlowMethodResponder handles the response to the UpdateFlowMethod request. The method always
    // closes the http.Response Body.
    func (client BaseClient) UpdateFlowMethodResponder(resp *http.Response) (result SetObjectType, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusAccepted,http.StatusBadRequest,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result.Value),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // UpdateJobMethod sends the update job request.
    func (client BaseClient) UpdateJobMethod(ctx context.Context, ID string, model JobType) (result SetObjectType, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.UpdateJobMethod")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                if err := validation.Validate([]validation.Validation{
                { TargetValue: model,
                 Constraints: []validation.Constraint{	{Target: "model.Name", Name: validation.Null, Rule: true, Chain: nil },
                	{Target: "model.Writeback", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "model.Writeback.WritebackID", Name: validation.Null, Rule: true, Chain: nil },
                }},
                	{Target: "model.LatestBatch", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "model.LatestBatch.Name", Name: validation.Null, Rule: true, Chain: nil },
                	{Target: "model.LatestBatch.JobID", Name: validation.Null, Rule: true, Chain: nil },
                }}}}}); err != nil {
                return result, validation.NewError(".BaseClient", "UpdateJobMethod", err.Error())
                }

                    req, err := client.UpdateJobMethodPreparer(ctx, ID, model)
        if err != nil {
        err = autorest.NewErrorWithError(err, ".BaseClient", "UpdateJobMethod", nil , "Failure preparing request")
        return
        }

                resp, err := client.UpdateJobMethodSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, ".BaseClient", "UpdateJobMethod", resp, "Failure sending request")
                return
                }

                result, err = client.UpdateJobMethodResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, ".BaseClient", "UpdateJobMethod", resp, "Failure responding to request")
                }

        return
        }

        // UpdateJobMethodPreparer prepares the UpdateJobMethod request.
        func (client BaseClient) UpdateJobMethodPreparer(ctx context.Context, ID string, model JobType) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPut(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v1/jobs/{id}",pathParameters),
        autorest.WithJSON(model))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // UpdateJobMethodSender sends the UpdateJobMethod request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) UpdateJobMethodSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // UpdateJobMethodResponder handles the response to the UpdateJobMethod request. The method always
    // closes the http.Response Body.
    func (client BaseClient) UpdateJobMethodResponder(resp *http.Response) (result SetObjectType, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusAccepted,http.StatusBadRequest,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result.Value),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // UpdateSchemaMethod sends the update schema request.
    func (client BaseClient) UpdateSchemaMethod(ctx context.Context, ID string, model SchemaType) (result SetObjectType, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.UpdateSchemaMethod")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                if err := validation.Validate([]validation.Validation{
                { TargetValue: model,
                 Constraints: []validation.Constraint{	{Target: "model.Name", Name: validation.Null, Rule: true, Chain: nil }}}}); err != nil {
                return result, validation.NewError(".BaseClient", "UpdateSchemaMethod", err.Error())
                }

                    req, err := client.UpdateSchemaMethodPreparer(ctx, ID, model)
        if err != nil {
        err = autorest.NewErrorWithError(err, ".BaseClient", "UpdateSchemaMethod", nil , "Failure preparing request")
        return
        }

                resp, err := client.UpdateSchemaMethodSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, ".BaseClient", "UpdateSchemaMethod", resp, "Failure sending request")
                return
                }

                result, err = client.UpdateSchemaMethodResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, ".BaseClient", "UpdateSchemaMethod", resp, "Failure responding to request")
                }

        return
        }

        // UpdateSchemaMethodPreparer prepares the UpdateSchemaMethod request.
        func (client BaseClient) UpdateSchemaMethodPreparer(ctx context.Context, ID string, model SchemaType) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPut(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v1/schemas/{id}",pathParameters),
        autorest.WithJSON(model))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // UpdateSchemaMethodSender sends the UpdateSchemaMethod request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) UpdateSchemaMethodSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // UpdateSchemaMethodResponder handles the response to the UpdateSchemaMethod request. The method always
    // closes the http.Response Body.
    func (client BaseClient) UpdateSchemaMethodResponder(resp *http.Response) (result SetObjectType, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusAccepted,http.StatusBadRequest,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result.Value),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // UpdateSchemaProfileMethod sends the update schema profile request.
    func (client BaseClient) UpdateSchemaProfileMethod(ctx context.Context, ID string, model SchemaProfileType) (result SetObjectType, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.UpdateSchemaProfileMethod")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                if err := validation.Validate([]validation.Validation{
                { TargetValue: model,
                 Constraints: []validation.Constraint{	{Target: "model.Name", Name: validation.Null, Rule: true, Chain: nil }}}}); err != nil {
                return result, validation.NewError(".BaseClient", "UpdateSchemaProfileMethod", err.Error())
                }

                    req, err := client.UpdateSchemaProfileMethodPreparer(ctx, ID, model)
        if err != nil {
        err = autorest.NewErrorWithError(err, ".BaseClient", "UpdateSchemaProfileMethod", nil , "Failure preparing request")
        return
        }

                resp, err := client.UpdateSchemaProfileMethodSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, ".BaseClient", "UpdateSchemaProfileMethod", resp, "Failure sending request")
                return
                }

                result, err = client.UpdateSchemaProfileMethodResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, ".BaseClient", "UpdateSchemaProfileMethod", resp, "Failure responding to request")
                }

        return
        }

        // UpdateSchemaProfileMethodPreparer prepares the UpdateSchemaProfileMethod request.
        func (client BaseClient) UpdateSchemaProfileMethodPreparer(ctx context.Context, ID string, model SchemaProfileType) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPut(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v1/schemaprofiles/{id}",pathParameters),
        autorest.WithJSON(model))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // UpdateSchemaProfileMethodSender sends the UpdateSchemaProfileMethod request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) UpdateSchemaProfileMethodSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // UpdateSchemaProfileMethodResponder handles the response to the UpdateSchemaProfileMethod request. The method always
    // closes the http.Response Body.
    func (client BaseClient) UpdateSchemaProfileMethodResponder(resp *http.Response) (result SetObjectType, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusAccepted,http.StatusBadRequest,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result.Value),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // UpdateShapeMethod sends the update shape request.
    func (client BaseClient) UpdateShapeMethod(ctx context.Context, ID string, model ShapeType) (result SetObjectType, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.UpdateShapeMethod")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                if err := validation.Validate([]validation.Validation{
                { TargetValue: model,
                 Constraints: []validation.Constraint{	{Target: "model.Name", Name: validation.Null, Rule: true, Chain: nil },
                	{Target: "model.MatchRule", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "model.MatchRule.ShapeID", Name: validation.Null, Rule: true, Chain: nil },
                	{Target: "model.MatchRule.Type", Name: validation.Null, Rule: true, Chain: nil },
                }}}}}); err != nil {
                return result, validation.NewError(".BaseClient", "UpdateShapeMethod", err.Error())
                }

                    req, err := client.UpdateShapeMethodPreparer(ctx, ID, model)
        if err != nil {
        err = autorest.NewErrorWithError(err, ".BaseClient", "UpdateShapeMethod", nil , "Failure preparing request")
        return
        }

                resp, err := client.UpdateShapeMethodSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, ".BaseClient", "UpdateShapeMethod", resp, "Failure sending request")
                return
                }

                result, err = client.UpdateShapeMethodResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, ".BaseClient", "UpdateShapeMethod", resp, "Failure responding to request")
                }

        return
        }

        // UpdateShapeMethodPreparer prepares the UpdateShapeMethod request.
        func (client BaseClient) UpdateShapeMethodPreparer(ctx context.Context, ID string, model ShapeType) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPut(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v1/shapes/{id}",pathParameters),
        autorest.WithJSON(model))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // UpdateShapeMethodSender sends the UpdateShapeMethod request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) UpdateShapeMethodSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // UpdateShapeMethodResponder handles the response to the UpdateShapeMethod request. The method always
    // closes the http.Response Body.
    func (client BaseClient) UpdateShapeMethodResponder(resp *http.Response) (result SetObjectType, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusAccepted,http.StatusBadRequest,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result.Value),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

