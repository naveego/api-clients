package

// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
    "encoding/json"
    "github.com/Azure/go-autorest/autorest"
    "github.com/Azure/go-autorest/autorest/date"
)

// The package's fully qualified name.
const fqdn = "go"

        // ConnectionRoleEnum enumerates the values for connection role enum.
    type ConnectionRoleEnum string

    const (
                // Publisher ...
        Publisher ConnectionRoleEnum = "publisher"
                // Subscriber ...
        Subscriber ConnectionRoleEnum = "subscriber"
            )
    // PossibleConnectionRoleEnumValues returns an array of possible values for the ConnectionRoleEnum const type.
    func PossibleConnectionRoleEnumValues() []ConnectionRoleEnum {
        return []ConnectionRoleEnum{Publisher,Subscriber}
    }

        // EdgeTypeEnum enumerates the values for edge type enum.
    type EdgeTypeEnum string

    const (
                // HTTP ...
        HTTP EdgeTypeEnum = "http"
                // InProcess ...
        InProcess EdgeTypeEnum = "inProcess"
                // Kafka ...
        Kafka EdgeTypeEnum = "kafka"
                // Unknown ...
        Unknown EdgeTypeEnum = "unknown"
            )
    // PossibleEdgeTypeEnumValues returns an array of possible values for the EdgeTypeEnum const type.
    func PossibleEdgeTypeEnumValues() []EdgeTypeEnum {
        return []EdgeTypeEnum{HTTP,InProcess,Kafka,Unknown}
    }

        // FilterRuleEffectEnum enumerates the values for filter rule effect enum.
    type FilterRuleEffectEnum string

    const (
                // Exclude ...
        Exclude FilterRuleEffectEnum = "exclude"
                // Include ...
        Include FilterRuleEffectEnum = "include"
            )
    // PossibleFilterRuleEffectEnumValues returns an array of possible values for the FilterRuleEffectEnum const type.
    func PossibleFilterRuleEffectEnumValues() []FilterRuleEffectEnum {
        return []FilterRuleEffectEnum{Exclude,Include}
    }

        // JobTypeEnum enumerates the values for job type enum.
    type JobTypeEnum string

    const (
                // Profiling ...
        Profiling JobTypeEnum = "profiling"
                // QualityCheck ...
        QualityCheck JobTypeEnum = "qualityCheck"
                // Read ...
        Read JobTypeEnum = "read"
                // Write ...
        Write JobTypeEnum = "write"
            )
    // PossibleJobTypeEnumValues returns an array of possible values for the JobTypeEnum const type.
    func PossibleJobTypeEnumValues() []JobTypeEnum {
        return []JobTypeEnum{Profiling,QualityCheck,Read,Write}
    }

        // MappingDirectionEnum enumerates the values for mapping direction enum.
    type MappingDirectionEnum string

    const (
                // SchemaToShape ...
        SchemaToShape MappingDirectionEnum = "schemaToShape"
                // ShapeToSchema ...
        ShapeToSchema MappingDirectionEnum = "shapeToSchema"
            )
    // PossibleMappingDirectionEnumValues returns an array of possible values for the MappingDirectionEnum const type.
    func PossibleMappingDirectionEnumValues() []MappingDirectionEnum {
        return []MappingDirectionEnum{SchemaToShape,ShapeToSchema}
    }

        // NodeTypeEnum enumerates the values for node type enum.
    type NodeTypeEnum string

    const (
                // NodeTypeEnumEnrich ...
        NodeTypeEnumEnrich NodeTypeEnum = "enrich"
                // NodeTypeEnumInjest ...
        NodeTypeEnumInjest NodeTypeEnum = "injest"
                // NodeTypeEnumMap ...
        NodeTypeEnumMap NodeTypeEnum = "map"
                // NodeTypeEnumMatch ...
        NodeTypeEnumMatch NodeTypeEnum = "match"
                // NodeTypeEnumMerge ...
        NodeTypeEnumMerge NodeTypeEnum = "merge"
                // NodeTypeEnumPublish ...
        NodeTypeEnumPublish NodeTypeEnum = "publish"
                // NodeTypeEnumTerminal ...
        NodeTypeEnumTerminal NodeTypeEnum = "terminal"
                // NodeTypeEnumUnknown ...
        NodeTypeEnumUnknown NodeTypeEnum = "unknown"
            )
    // PossibleNodeTypeEnumValues returns an array of possible values for the NodeTypeEnum const type.
    func PossibleNodeTypeEnumValues() []NodeTypeEnum {
        return []NodeTypeEnum{NodeTypeEnumEnrich,NodeTypeEnumInjest,NodeTypeEnumMap,NodeTypeEnumMatch,NodeTypeEnumMerge,NodeTypeEnumPublish,NodeTypeEnumTerminal,NodeTypeEnumUnknown}
    }

        // PropertyIDMeaningEnum enumerates the values for property id meaning enum.
    type PropertyIDMeaningEnum string

    const (
                // EnrichedDataPropertyID ...
        EnrichedDataPropertyID PropertyIDMeaningEnum = "enrichedDataPropertyId"
                // PrimaryDataPropertyID ...
        PrimaryDataPropertyID PropertyIDMeaningEnum = "primaryDataPropertyId"
                // SchemaDataPropertyID ...
        SchemaDataPropertyID PropertyIDMeaningEnum = "schemaDataPropertyId"
            )
    // PossiblePropertyIDMeaningEnumValues returns an array of possible values for the PropertyIDMeaningEnum const type.
    func PossiblePropertyIDMeaningEnumValues() []PropertyIDMeaningEnum {
        return []PropertyIDMeaningEnum{EnrichedDataPropertyID,PrimaryDataPropertyID,SchemaDataPropertyID}
    }

        // PropertyTypeEnum enumerates the values for property type enum.
    type PropertyTypeEnum string

    const (
                // Blob ...
        Blob PropertyTypeEnum = "blob"
                // Bool ...
        Bool PropertyTypeEnum = "bool"
                // Date ...
        Date PropertyTypeEnum = "date"
                // Datetime ...
        Datetime PropertyTypeEnum = "datetime"
                // Decimal ...
        Decimal PropertyTypeEnum = "decimal"
                // Float ...
        Float PropertyTypeEnum = "float"
                // Integer ...
        Integer PropertyTypeEnum = "integer"
                // JSON ...
        JSON PropertyTypeEnum = "json"
                // String ...
        String PropertyTypeEnum = "string"
                // Text ...
        Text PropertyTypeEnum = "text"
                // Time ...
        Time PropertyTypeEnum = "time"
            )
    // PossiblePropertyTypeEnumValues returns an array of possible values for the PropertyTypeEnum const type.
    func PossiblePropertyTypeEnumValues() []PropertyTypeEnum {
        return []PropertyTypeEnum{Blob,Bool,Date,Datetime,Decimal,Float,Integer,JSON,String,Text,Time}
    }

        // ScheduleTypeEnum enumerates the values for schedule type enum.
    type ScheduleTypeEnum string

    const (
                // Always ...
        Always ScheduleTypeEnum = "always"
                // Cron ...
        Cron ScheduleTypeEnum = "cron"
                // Immediate ...
        Immediate ScheduleTypeEnum = "immediate"
                // Interval ...
        Interval ScheduleTypeEnum = "interval"
                // Never ...
        Never ScheduleTypeEnum = "never"
                // Once ...
        Once ScheduleTypeEnum = "once"
                // OnDemand ...
        OnDemand ScheduleTypeEnum = "onDemand"
                // RealTime ...
        RealTime ScheduleTypeEnum = "realTime"
            )
    // PossibleScheduleTypeEnumValues returns an array of possible values for the ScheduleTypeEnum const type.
    func PossibleScheduleTypeEnumValues() []ScheduleTypeEnum {
        return []ScheduleTypeEnum{Always,Cron,Immediate,Interval,Never,Once,OnDemand,RealTime}
    }

        // SchemaCapabilityEnum enumerates the values for schema capability enum.
    type SchemaCapabilityEnum string

    const (
                // SchemaCapabilityEnumQualityCheck ...
        SchemaCapabilityEnumQualityCheck SchemaCapabilityEnum = "qualityCheck"
                // SchemaCapabilityEnumRead ...
        SchemaCapabilityEnumRead SchemaCapabilityEnum = "read"
                // SchemaCapabilityEnumReadWrite ...
        SchemaCapabilityEnumReadWrite SchemaCapabilityEnum = "readWrite"
                // SchemaCapabilityEnumWrite ...
        SchemaCapabilityEnumWrite SchemaCapabilityEnum = "write"
            )
    // PossibleSchemaCapabilityEnumValues returns an array of possible values for the SchemaCapabilityEnum const type.
    func PossibleSchemaCapabilityEnumValues() []SchemaCapabilityEnum {
        return []SchemaCapabilityEnum{SchemaCapabilityEnumQualityCheck,SchemaCapabilityEnumRead,SchemaCapabilityEnumReadWrite,SchemaCapabilityEnumWrite}
    }

        // SecurityAlgorithmEnum enumerates the values for security algorithm enum.
    type SecurityAlgorithmEnum string

    const (
                // Aesgcm ...
        Aesgcm SecurityAlgorithmEnum = "aesgcm"
                // None ...
        None SecurityAlgorithmEnum = "none"
                // Sha256Hmac ...
        Sha256Hmac SecurityAlgorithmEnum = "sha256Hmac"
            )
    // PossibleSecurityAlgorithmEnumValues returns an array of possible values for the SecurityAlgorithmEnum const type.
    func PossibleSecurityAlgorithmEnumValues() []SecurityAlgorithmEnum {
        return []SecurityAlgorithmEnum{Aesgcm,None,Sha256Hmac}
    }

        // SecurityKeyStorageEnum enumerates the values for security key storage enum.
    type SecurityKeyStorageEnum string

    const (
                // File ...
        File SecurityKeyStorageEnum = "file"
                // Vault ...
        Vault SecurityKeyStorageEnum = "vault"
            )
    // PossibleSecurityKeyStorageEnumValues returns an array of possible values for the SecurityKeyStorageEnum const type.
    func PossibleSecurityKeyStorageEnumValues() []SecurityKeyStorageEnum {
        return []SecurityKeyStorageEnum{File,Vault}
    }

        // TraitAttributeTypeEnum enumerates the values for trait attribute type enum.
    type TraitAttributeTypeEnum string

    const (
                // TraitAttributeTypeEnumBoxplot ...
        TraitAttributeTypeEnumBoxplot TraitAttributeTypeEnum = "boxplot"
                // TraitAttributeTypeEnumCount ...
        TraitAttributeTypeEnumCount TraitAttributeTypeEnum = "count"
                // TraitAttributeTypeEnumDetails ...
        TraitAttributeTypeEnumDetails TraitAttributeTypeEnum = "details"
                // TraitAttributeTypeEnumHistogram ...
        TraitAttributeTypeEnumHistogram TraitAttributeTypeEnum = "histogram"
                // TraitAttributeTypeEnumPercent ...
        TraitAttributeTypeEnumPercent TraitAttributeTypeEnum = "percent"
                // TraitAttributeTypeEnumStatistic ...
        TraitAttributeTypeEnumStatistic TraitAttributeTypeEnum = "statistic"
                // TraitAttributeTypeEnumString ...
        TraitAttributeTypeEnumString TraitAttributeTypeEnum = "string"
            )
    // PossibleTraitAttributeTypeEnumValues returns an array of possible values for the TraitAttributeTypeEnum const type.
    func PossibleTraitAttributeTypeEnumValues() []TraitAttributeTypeEnum {
        return []TraitAttributeTypeEnum{TraitAttributeTypeEnumBoxplot,TraitAttributeTypeEnumCount,TraitAttributeTypeEnumDetails,TraitAttributeTypeEnumHistogram,TraitAttributeTypeEnumPercent,TraitAttributeTypeEnumStatistic,TraitAttributeTypeEnumString}
    }

            // BatchStatusGoBetweenScopeType ...
            type BatchStatusGoBetweenScopeType struct {
            ResourceID *string `json:"resourceId,omitempty"`
            UpdatedAt *date.Time `json:"updatedAt,omitempty"`
            UpdatedBy *string `json:"updatedBy,omitempty"`
            StartedOnAgent *string `json:"startedOnAgent,omitempty"`
            StartedAt *date.Time `json:"startedAt,omitempty"`
            ExpectedToEndBefore *date.Time `json:"expectedToEndBefore,omitempty"`
            EndedAt *date.Time `json:"endedAt,omitempty"`
            ExpectedCount *int32 `json:"expectedCount,omitempty"`
            DataPointsPerMinute *float64 `json:"dataPointsPerMinute,omitempty"`
            Count *int32 `json:"count,omitempty"`
            FilteredCount *int32 `json:"filteredCount,omitempty"`
            DeflectedCount *int32 `json:"deflectedCount,omitempty"`
            BadRecordCount *int32 `json:"badRecordCount,omitempty"`
            EndedReason *string `json:"endedReason,omitempty"`
            EndedMessage *string `json:"endedMessage,omitempty"`
            BadRecordSample *[]map[string]interface{} `json:"badRecordSample,omitempty"`
            }

            // BatchStatusType ...
            type BatchStatusType struct {
            ResourceID *string `json:"resourceId,omitempty"`
            UpdatedAt *date.Time `json:"updatedAt,omitempty"`
            UpdatedBy *string `json:"updatedBy,omitempty"`
            GoBetweenAgent *BatchStatusGoBetweenScopeType `json:"goBetweenAgent,omitempty"`
            }

            // BatchType ...
            type BatchType struct {
            autorest.Response `json:"-"`
            ID *string `json:"id,omitempty"`
            Version *int32 `json:"version,omitempty"`
            Name *string `json:"name,omitempty"`
            Description *string `json:"description,omitempty"`
            JobID *string `json:"jobId,omitempty"`
            Status *BatchStatusType `json:"status,omitempty"`
            CreatedAt *date.Time `json:"createdAt,omitempty"`
            CreatedBy *string `json:"createdBy,omitempty"`
            UpdatedAt *date.Time `json:"updatedAt,omitempty"`
            UpdatedBy *string `json:"updatedBy,omitempty"`
            DeletedAt *date.Time `json:"deletedAt,omitempty"`
            DeletedBy *string `json:"deletedBy,omitempty"`
            }

            // BoxplotType ...
            type BoxplotType struct {
            Min *float64 `json:"min,omitempty"`
            Q1 *float64 `json:"q1,omitempty"`
            Median *float64 `json:"median,omitempty"`
            Q3 *float64 `json:"q3,omitempty"`
            Max *float64 `json:"max,omitempty"`
            }

            // ConnectionDiscoveredSchemaType ...
            type ConnectionDiscoveredSchemaType struct {
            DiscoveredSchemaID *string `json:"discoveredSchemaId,omitempty"`
            IsAdvertised *bool `json:"isAdvertised,omitempty"`
            AdvertisedSchemaID *string `json:"advertisedSchemaId,omitempty"`
            }

            // ConnectionType ...
            type ConnectionType struct {
            autorest.Response `json:"-"`
            ID *string `json:"id,omitempty"`
            Version *int32 `json:"version,omitempty"`
            Name *string `json:"name,omitempty"`
            Description *string `json:"description,omitempty"`
            Roles *[]ConnectionRoleEnum `json:"roles,omitempty"`
            Labels map[string]*string `json:"labels"`
            Plugin *string `json:"plugin,omitempty"`
            Settings map[string]interface{} `json:"settings"`
            PreferredAgent *string `json:"preferredAgent,omitempty"`
            CanRunInCloud *bool `json:"canRunInCloud,omitempty"`
            PluginCapabilities *PluginCapabilitiesType `json:"pluginCapabilities,omitempty"`
            DiscoveredSchemas *[]ConnectionDiscoveredSchemaType `json:"discoveredSchemas,omitempty"`
            CreatedAt *date.Time `json:"createdAt,omitempty"`
            CreatedBy *string `json:"createdBy,omitempty"`
            UpdatedAt *date.Time `json:"updatedAt,omitempty"`
            UpdatedBy *string `json:"updatedBy,omitempty"`
            DeletedAt *date.Time `json:"deletedAt,omitempty"`
            DeletedBy *string `json:"deletedBy,omitempty"`
            }

        // MarshalJSON is the custom marshaler for ConnectionType.
        func (ct ConnectionType)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(ct.ID != nil) {
                objectMap["id"] = ct.ID
                }
                if(ct.Version != nil) {
                objectMap["version"] = ct.Version
                }
                if(ct.Name != nil) {
                objectMap["name"] = ct.Name
                }
                if(ct.Description != nil) {
                objectMap["description"] = ct.Description
                }
                if(ct.Roles != nil) {
                objectMap["roles"] = ct.Roles
                }
                if(ct.Labels != nil) {
                objectMap["labels"] = ct.Labels
                }
                if(ct.Plugin != nil) {
                objectMap["plugin"] = ct.Plugin
                }
                if(ct.Settings != nil) {
                objectMap["settings"] = ct.Settings
                }
                if(ct.PreferredAgent != nil) {
                objectMap["preferredAgent"] = ct.PreferredAgent
                }
                if(ct.CanRunInCloud != nil) {
                objectMap["canRunInCloud"] = ct.CanRunInCloud
                }
                if(ct.PluginCapabilities != nil) {
                objectMap["pluginCapabilities"] = ct.PluginCapabilities
                }
                if(ct.DiscoveredSchemas != nil) {
                objectMap["discoveredSchemas"] = ct.DiscoveredSchemas
                }
                if(ct.CreatedAt != nil) {
                objectMap["createdAt"] = ct.CreatedAt
                }
                if(ct.CreatedBy != nil) {
                objectMap["createdBy"] = ct.CreatedBy
                }
                if(ct.UpdatedAt != nil) {
                objectMap["updatedAt"] = ct.UpdatedAt
                }
                if(ct.UpdatedBy != nil) {
                objectMap["updatedBy"] = ct.UpdatedBy
                }
                if(ct.DeletedAt != nil) {
                objectMap["deletedAt"] = ct.DeletedAt
                }
                if(ct.DeletedBy != nil) {
                objectMap["deletedBy"] = ct.DeletedBy
                }
                return json.Marshal(objectMap)
        }

            // DataflowEventType ...
            type DataflowEventType struct {
            autorest.Response `json:"-"`
            D *PayloadType `json:"d,omitempty"`
            ID *string `json:"id,omitempty"`
            Tid *string `json:"tid,omitempty"`
            Sid *string `json:"sid,omitempty"`
            Jid *string `json:"jid,omitempty"`
            Bid *string `json:"bid,omitempty"`
            Rid *string `json:"rid,omitempty"`
            Rids *[]string `json:"rids,omitempty"`
            Cid *string `json:"cid,omitempty"`
            M map[string]interface{} `json:"m"`
            Trc *[]TraceType `json:"trc,omitempty"`
            }

        // MarshalJSON is the custom marshaler for DataflowEventType.
        func (det DataflowEventType)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(det.D != nil) {
                objectMap["d"] = det.D
                }
                if(det.ID != nil) {
                objectMap["id"] = det.ID
                }
                if(det.Tid != nil) {
                objectMap["tid"] = det.Tid
                }
                if(det.Sid != nil) {
                objectMap["sid"] = det.Sid
                }
                if(det.Jid != nil) {
                objectMap["jid"] = det.Jid
                }
                if(det.Bid != nil) {
                objectMap["bid"] = det.Bid
                }
                if(det.Rid != nil) {
                objectMap["rid"] = det.Rid
                }
                if(det.Rids != nil) {
                objectMap["rids"] = det.Rids
                }
                if(det.Cid != nil) {
                objectMap["cid"] = det.Cid
                }
                if(det.M != nil) {
                objectMap["m"] = det.M
                }
                if(det.Trc != nil) {
                objectMap["trc"] = det.Trc
                }
                return json.Marshal(objectMap)
        }

            // EdgeType ...
            type EdgeType struct {
            ID *string `json:"id,omitempty"`
            FromID *string `json:"fromId,omitempty"`
            ToID *string `json:"toId,omitempty"`
            // Type - Possible values include: 'Unknown', 'InProcess', 'Kafka', 'HTTP'
            Type EdgeTypeEnum `json:"type,omitempty"`
            InProcess interface{} `json:"inProcess,omitempty"`
            Kafka *KafkaEdgeType `json:"kafka,omitempty"`
            HTTP *HTTPEdgeType `json:"http,omitempty"`
            }

            // FilterRuleType ...
            type FilterRuleType struct {
            // Effect - Possible values include: 'Include', 'Exclude'
            Effect FilterRuleEffectEnum `json:"effect,omitempty"`
            PropertyID *string `json:"propertyId,omitempty"`
            OperatorID *string `json:"operatorId,omitempty"`
            Parameter interface{} `json:"parameter,omitempty"`
            }

            // FilterType ...
            type FilterType struct {
            Rules *[]FilterRuleType `json:"rules,omitempty"`
            }

            // FlowType ...
            type FlowType struct {
            autorest.Response `json:"-"`
            ID *string `json:"id,omitempty"`
            Version *int32 `json:"version,omitempty"`
            Name *string `json:"name,omitempty"`
            Description *string `json:"description,omitempty"`
            Nodes map[string]*NodeType `json:"nodes"`
            Edges map[string]*EdgeType `json:"edges"`
            CreatedAt *date.Time `json:"createdAt,omitempty"`
            CreatedBy *string `json:"createdBy,omitempty"`
            UpdatedAt *date.Time `json:"updatedAt,omitempty"`
            UpdatedBy *string `json:"updatedBy,omitempty"`
            DeletedAt *date.Time `json:"deletedAt,omitempty"`
            DeletedBy *string `json:"deletedBy,omitempty"`
            }

        // MarshalJSON is the custom marshaler for FlowType.
        func (ft FlowType)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(ft.ID != nil) {
                objectMap["id"] = ft.ID
                }
                if(ft.Version != nil) {
                objectMap["version"] = ft.Version
                }
                if(ft.Name != nil) {
                objectMap["name"] = ft.Name
                }
                if(ft.Description != nil) {
                objectMap["description"] = ft.Description
                }
                if(ft.Nodes != nil) {
                objectMap["nodes"] = ft.Nodes
                }
                if(ft.Edges != nil) {
                objectMap["edges"] = ft.Edges
                }
                if(ft.CreatedAt != nil) {
                objectMap["createdAt"] = ft.CreatedAt
                }
                if(ft.CreatedBy != nil) {
                objectMap["createdBy"] = ft.CreatedBy
                }
                if(ft.UpdatedAt != nil) {
                objectMap["updatedAt"] = ft.UpdatedAt
                }
                if(ft.UpdatedBy != nil) {
                objectMap["updatedBy"] = ft.UpdatedBy
                }
                if(ft.DeletedAt != nil) {
                objectMap["deletedAt"] = ft.DeletedAt
                }
                if(ft.DeletedBy != nil) {
                objectMap["deletedBy"] = ft.DeletedBy
                }
                return json.Marshal(objectMap)
        }

            // HistogramType ...
            type HistogramType struct {
            Min *float64 `json:"min,omitempty"`
            Max *float64 `json:"max,omitempty"`
            Count *int64 `json:"count,omitempty"`
            Frequencies *[]float64 `json:"frequencies,omitempty"`
            }

            // HTTPEdgeType ...
            type HTTPEdgeType struct {
            Endpoint *string `json:"endpoint,omitempty"`
            }

            // JobStatusGoBetweenScopeType ...
            type JobStatusGoBetweenScopeType struct {
            ResourceID *string `json:"resourceId,omitempty"`
            UpdatedAt *date.Time `json:"updatedAt,omitempty"`
            UpdatedBy *string `json:"updatedBy,omitempty"`
            Error *string `json:"error,omitempty"`
            Message *string `json:"message,omitempty"`
            StartCount *int32 `json:"startCount,omitempty"`
            SuccessCount *int32 `json:"successCount,omitempty"`
            ConsecutiveFailureCount *int32 `json:"consecutiveFailureCount,omitempty"`
            State *string `json:"state,omitempty"`
            NextRunAt *date.Time `json:"nextRunAt,omitempty"`
            PreviousRunAt *date.Time `json:"previousRunAt,omitempty"`
            ScheduledOn *string `json:"scheduledOn,omitempty"`
            ScheduledAt *date.Time `json:"scheduledAt,omitempty"`
            }

            // JobStatusType ...
            type JobStatusType struct {
            ResourceID *string `json:"resourceId,omitempty"`
            UpdatedAt *date.Time `json:"updatedAt,omitempty"`
            UpdatedBy *string `json:"updatedBy,omitempty"`
            GoBetween *JobStatusGoBetweenScopeType `json:"goBetween,omitempty"`
            RealTime *RealTimeStateScopeType `json:"realTime,omitempty"`
            }

            // JobType ...
            type JobType struct {
            autorest.Response `json:"-"`
            ID *string `json:"id,omitempty"`
            Version *int32 `json:"version,omitempty"`
            Name *string `json:"name,omitempty"`
            Description *string `json:"description,omitempty"`
            Schedule *ScheduleType `json:"schedule,omitempty"`
            ConnectionID *string `json:"connectionId,omitempty"`
            SchemaID *string `json:"schemaId,omitempty"`
            ShapeID *string `json:"shapeId,omitempty"`
            AgentID *string `json:"agentId,omitempty"`
            CanRunInCloud *bool `json:"canRunInCloud,omitempty"`
            DataVersion *int32 `json:"dataVersion,omitempty"`
            PropertyMappings *[]PropertyMappingType `json:"propertyMappings,omitempty"`
            // Type - Possible values include: 'Read', 'Write', 'Profiling', 'QualityCheck'
            Type JobTypeEnum `json:"type,omitempty"`
            IsPaused *bool `json:"isPaused,omitempty"`
            Writeback *WritebackType `json:"writeback,omitempty"`
            Filter *FilterType `json:"filter,omitempty"`
            Status *JobStatusType `json:"status,omitempty"`
            LatestBatch *BatchType `json:"latestBatch,omitempty"`
            CreatedAt *date.Time `json:"createdAt,omitempty"`
            CreatedBy *string `json:"createdBy,omitempty"`
            UpdatedAt *date.Time `json:"updatedAt,omitempty"`
            UpdatedBy *string `json:"updatedBy,omitempty"`
            DeletedAt *date.Time `json:"deletedAt,omitempty"`
            DeletedBy *string `json:"deletedBy,omitempty"`
            }

            // KafkaEdgeType ...
            type KafkaEdgeType struct {
            TopicTemplate *string `json:"topicTemplate,omitempty"`
            }

            // ListBatchType ...
            type ListBatchType struct {
            autorest.Response `json:"-"`
            Value *[]BatchType `json:"value,omitempty"`
            }

            // ListConnectionType ...
            type ListConnectionType struct {
            autorest.Response `json:"-"`
            Value *[]ConnectionType `json:"value,omitempty"`
            }

            // ListFlowType ...
            type ListFlowType struct {
            autorest.Response `json:"-"`
            Value *[]FlowType `json:"value,omitempty"`
            }

            // ListJobType ...
            type ListJobType struct {
            autorest.Response `json:"-"`
            Value *[]JobType `json:"value,omitempty"`
            }

            // ListSchemaProfileType ...
            type ListSchemaProfileType struct {
            autorest.Response `json:"-"`
            Value *[]SchemaProfileType `json:"value,omitempty"`
            }

            // ListSchemaType ...
            type ListSchemaType struct {
            autorest.Response `json:"-"`
            Value *[]SchemaType `json:"value,omitempty"`
            }

            // ListShapeType ...
            type ListShapeType struct {
            autorest.Response `json:"-"`
            Value *[]ShapeType `json:"value,omitempty"`
            }

            // MapNodeType ...
            type MapNodeType struct {
            MappingID *string `json:"mappingId,omitempty"`
            }

            // MappingType ...
            type MappingType struct {
            autorest.Response `json:"-"`
            ID *string `json:"id,omitempty"`
            Version *int32 `json:"version,omitempty"`
            Name *string `json:"name,omitempty"`
            Description *string `json:"description,omitempty"`
            // Direction - Possible values include: 'SchemaToShape', 'ShapeToSchema'
            Direction MappingDirectionEnum `json:"direction,omitempty"`
            SchemaID *string `json:"schemaId,omitempty"`
            ShapeID *string `json:"shapeId,omitempty"`
            PropertyMappings *[]PropertyMappingType `json:"propertyMappings,omitempty"`
            CreatedAt *date.Time `json:"createdAt,omitempty"`
            CreatedBy *string `json:"createdBy,omitempty"`
            UpdatedAt *date.Time `json:"updatedAt,omitempty"`
            UpdatedBy *string `json:"updatedBy,omitempty"`
            DeletedAt *date.Time `json:"deletedAt,omitempty"`
            DeletedBy *string `json:"deletedBy,omitempty"`
            }

            // MatchRuleType ...
            type MatchRuleType struct {
            ShapeID *string `json:"shapeId,omitempty"`
            Version *int32 `json:"version,omitempty"`
            Mcl *float64 `json:"mcl,omitempty"`
            Type *string `json:"type,omitempty"`
            Settings map[string]interface{} `json:"settings"`
            }

        // MarshalJSON is the custom marshaler for MatchRuleType.
        func (mrt MatchRuleType)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(mrt.ShapeID != nil) {
                objectMap["shapeId"] = mrt.ShapeID
                }
                if(mrt.Version != nil) {
                objectMap["version"] = mrt.Version
                }
                if(mrt.Mcl != nil) {
                objectMap["mcl"] = mrt.Mcl
                }
                if(mrt.Type != nil) {
                objectMap["type"] = mrt.Type
                }
                if(mrt.Settings != nil) {
                objectMap["settings"] = mrt.Settings
                }
                return json.Marshal(objectMap)
        }

            // MergeRuleType ...
            type MergeRuleType struct {
            Version *int32 `json:"version,omitempty"`
            Properties map[string]*PropertyMergeRuleType `json:"properties"`
            }

        // MarshalJSON is the custom marshaler for MergeRuleType.
        func (mrt MergeRuleType)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(mrt.Version != nil) {
                objectMap["version"] = mrt.Version
                }
                if(mrt.Properties != nil) {
                objectMap["properties"] = mrt.Properties
                }
                return json.Marshal(objectMap)
        }

            // NodeType ...
            type NodeType struct {
            ID *string `json:"id,omitempty"`
            Name *string `json:"name,omitempty"`
            // Type - Possible values include: 'NodeTypeEnumUnknown', 'NodeTypeEnumPublish', 'NodeTypeEnumMap', 'NodeTypeEnumInjest', 'NodeTypeEnumEnrich', 'NodeTypeEnumMatch', 'NodeTypeEnumMerge', 'NodeTypeEnumTerminal'
            Type NodeTypeEnum `json:"type,omitempty"`
            Publish *PublishNodeType `json:"publish,omitempty"`
            Map *MapNodeType `json:"map,omitempty"`
            Injest interface{} `json:"injest,omitempty"`
            Match interface{} `json:"match,omitempty"`
            Merge interface{} `json:"merge,omitempty"`
            Terminal interface{} `json:"terminal,omitempty"`
            }

            // PagedResultOfBatchStatusType ...
            type PagedResultOfBatchStatusType struct {
            autorest.Response `json:"-"`
            PageSize *int32 `json:"pageSize,omitempty"`
            CurrentPage *int64 `json:"currentPage,omitempty"`
            TotalItems *int64 `json:"totalItems,omitempty"`
            Items *[]BatchStatusType `json:"items,omitempty"`
            }

            // PagedResultOfJobStatusType ...
            type PagedResultOfJobStatusType struct {
            autorest.Response `json:"-"`
            PageSize *int32 `json:"pageSize,omitempty"`
            CurrentPage *int64 `json:"currentPage,omitempty"`
            TotalItems *int64 `json:"totalItems,omitempty"`
            Items *[]JobStatusType `json:"items,omitempty"`
            }

            // PayloadType ...
            type PayloadType struct {
            M interface{} `json:"m,omitempty"`
            }

            // PluginCapabilitiesType ...
            type PluginCapabilitiesType struct {
            CanAcceptQueryBasedSchemas *bool `json:"canAcceptQueryBasedSchemas,omitempty"`
            CanConfigure *bool `json:"canConfigure,omitempty"`
            CanConfigureConnection *bool `json:"canConfigureConnection,omitempty"`
            CanConfigureQualityCheck *bool `json:"canConfigureQualityCheck,omitempty"`
            CanConfigureQuery *bool `json:"canConfigureQuery,omitempty"`
            CanConfigureRealTime *bool `json:"canConfigureRealTime,omitempty"`
            CanConfigureWrite *bool `json:"canConfigureWrite,omitempty"`
            CanDiscoverShapes *bool `json:"canDiscoverShapes,omitempty"`
            CanProduceMultipleSchemas *bool `json:"canProduceMultipleSchemas,omitempty"`
            CanPublish *bool `json:"canPublish,omitempty"`
            CanUseOAuth *bool `json:"canUseOAuth,omitempty"`
            CanWrite *bool `json:"canWrite,omitempty"`
            }

            // PropertyMappingType ...
            type PropertyMappingType struct {
            FromPropertyID *string `json:"fromPropertyId,omitempty"`
            ToPropertyID *string `json:"toPropertyId,omitempty"`
            // FromPropertyMeaning - Possible values include: 'PrimaryDataPropertyID', 'SchemaDataPropertyID', 'EnrichedDataPropertyID'
            FromPropertyMeaning PropertyIDMeaningEnum `json:"fromPropertyMeaning,omitempty"`
            // ToPropertyMeaning - Possible values include: 'PrimaryDataPropertyID', 'SchemaDataPropertyID', 'EnrichedDataPropertyID'
            ToPropertyMeaning PropertyIDMeaningEnum `json:"toPropertyMeaning,omitempty"`
            Transform *TransformType `json:"transform,omitempty"`
            Transforms *[]TransformType `json:"transforms,omitempty"`
            }

            // PropertyMergeRuleType ...
            type PropertyMergeRuleType struct {
            PropertyID *string `json:"propertyId,omitempty"`
            Connections *[]string `json:"connections,omitempty"`
            }

            // PropertyTraitType ...
            type PropertyTraitType struct {
            PropertyID *string `json:"propertyId,omitempty"`
            ID *string `json:"id,omitempty"`
            Error *string `json:"error,omitempty"`
            AttributeValues map[string]interface{} `json:"attributeValues"`
            }

        // MarshalJSON is the custom marshaler for PropertyTraitType.
        func (ptt PropertyTraitType)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(ptt.PropertyID != nil) {
                objectMap["propertyId"] = ptt.PropertyID
                }
                if(ptt.ID != nil) {
                objectMap["id"] = ptt.ID
                }
                if(ptt.Error != nil) {
                objectMap["error"] = ptt.Error
                }
                if(ptt.AttributeValues != nil) {
                objectMap["attributeValues"] = ptt.AttributeValues
                }
                return json.Marshal(objectMap)
        }

            // PublishNodeType ...
            type PublishNodeType struct {
            ShapeID *string `json:"shapeId,omitempty"`
            ConnectionID *string `json:"connectionId,omitempty"`
            }

            // RealTimeSettingsType ...
            type RealTimeSettingsType struct {
            StateCheckpointInterval *string `json:"stateCheckpointInterval,omitempty"`
            Settings map[string]interface{} `json:"settings"`
            Schema map[string]interface{} `json:"schema"`
            UISchema map[string]interface{} `json:"uiSchema"`
            }

        // MarshalJSON is the custom marshaler for RealTimeSettingsType.
        func (rtst RealTimeSettingsType)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(rtst.StateCheckpointInterval != nil) {
                objectMap["stateCheckpointInterval"] = rtst.StateCheckpointInterval
                }
                if(rtst.Settings != nil) {
                objectMap["settings"] = rtst.Settings
                }
                if(rtst.Schema != nil) {
                objectMap["schema"] = rtst.Schema
                }
                if(rtst.UISchema != nil) {
                objectMap["uiSchema"] = rtst.UISchema
                }
                return json.Marshal(objectMap)
        }

            // RealTimeStateScopeType ...
            type RealTimeStateScopeType struct {
            ResourceID *string `json:"resourceId,omitempty"`
            UpdatedAt *date.Time `json:"updatedAt,omitempty"`
            UpdatedBy *string `json:"updatedBy,omitempty"`
            RealTimeState *string `json:"realTimeState,omitempty"`
            }

            // ScheduleType ...
            type ScheduleType struct {
            // Type - Possible values include: 'Never', 'Immediate', 'OnDemand', 'Once', 'Interval', 'Cron', 'RealTime', 'Always'
            Type ScheduleTypeEnum `json:"type,omitempty"`
            Cron *string `json:"cron,omitempty"`
            PointInTime *date.Time `json:"pointInTime,omitempty"`
            Description *string `json:"description,omitempty"`
            RealTimeSettings *RealTimeSettingsType `json:"realTimeSettings,omitempty"`
            }

            // SchemaFormType ...
            type SchemaFormType struct {
            Settings map[string]interface{} `json:"settings"`
            JSONSchema map[string]interface{} `json:"jsonSchema"`
            UISchema map[string]interface{} `json:"uiSchema"`
            }

        // MarshalJSON is the custom marshaler for SchemaFormType.
        func (sft SchemaFormType)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(sft.Settings != nil) {
                objectMap["settings"] = sft.Settings
                }
                if(sft.JSONSchema != nil) {
                objectMap["jsonSchema"] = sft.JSONSchema
                }
                if(sft.UISchema != nil) {
                objectMap["uiSchema"] = sft.UISchema
                }
                return json.Marshal(objectMap)
        }

            // SchemaProfileType ...
            type SchemaProfileType struct {
            autorest.Response `json:"-"`
            ID *string `json:"id,omitempty"`
            Version *int32 `json:"version,omitempty"`
            Name *string `json:"name,omitempty"`
            Description *string `json:"description,omitempty"`
            SchemaVersion *int32 `json:"schemaVersion,omitempty"`
            ConnectionID *string `json:"connectionId,omitempty"`
            Count *int64 `json:"count,omitempty"`
            StartedOn *date.Time `json:"startedOn,omitempty"`
            CompletedOn *date.Time `json:"completedOn,omitempty"`
            TraitDefinitions *[]TraitDefinitionType `json:"traitDefinitions,omitempty"`
            SchemaTraits *[]SchemaTraitType `json:"schemaTraits,omitempty"`
            PropertyTraits *[]PropertyTraitType `json:"propertyTraits,omitempty"`
            CreatedAt *date.Time `json:"createdAt,omitempty"`
            CreatedBy *string `json:"createdBy,omitempty"`
            UpdatedAt *date.Time `json:"updatedAt,omitempty"`
            UpdatedBy *string `json:"updatedBy,omitempty"`
            DeletedAt *date.Time `json:"deletedAt,omitempty"`
            DeletedBy *string `json:"deletedBy,omitempty"`
            }

            // SchemaPropertyType ...
            type SchemaPropertyType struct {
            ID *string `json:"id,omitempty"`
            Name *string `json:"name,omitempty"`
            DiscoveredName *string `json:"discoveredName,omitempty"`
            DiscoveredDescription *string `json:"discoveredDescription,omitempty"`
            Description *string `json:"description,omitempty"`
            // Type - Possible values include: 'String', 'Bool', 'Integer', 'Float', 'Decimal', 'Date', 'Time', 'Datetime', 'Text', 'Blob', 'JSON'
            Type PropertyTypeEnum `json:"type,omitempty"`
            DiscoveredType *string `json:"discoveredType,omitempty"`
            IsKey *bool `json:"isKey,omitempty"`
            IsNullable *bool `json:"isNullable,omitempty"`
            IsCreateCounter *bool `json:"isCreateCounter,omitempty"`
            IsUpdateCounter *bool `json:"isUpdateCounter,omitempty"`
            PublisherMetaJSON *string `json:"publisherMetaJson,omitempty"`
            }

            // SchemaTraitType ...
            type SchemaTraitType struct {
            ID *string `json:"id,omitempty"`
            Error *string `json:"error,omitempty"`
            AttributeValues map[string]interface{} `json:"attributeValues"`
            }

        // MarshalJSON is the custom marshaler for SchemaTraitType.
        func (stt SchemaTraitType)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(stt.ID != nil) {
                objectMap["id"] = stt.ID
                }
                if(stt.Error != nil) {
                objectMap["error"] = stt.Error
                }
                if(stt.AttributeValues != nil) {
                objectMap["attributeValues"] = stt.AttributeValues
                }
                return json.Marshal(objectMap)
        }

            // SchemaType ...
            type SchemaType struct {
            autorest.Response `json:"-"`
            ID *string `json:"id,omitempty"`
            Version *int32 `json:"version,omitempty"`
            Name *string `json:"name,omitempty"`
            Description *string `json:"description,omitempty"`
            DiscoveredID *string `json:"discoveredId,omitempty"`
            DiscoveredName *string `json:"discoveredName,omitempty"`
            DiscoveredDescription *string `json:"discoveredDescription,omitempty"`
            IsUserDefined *bool `json:"isUserDefined,omitempty"`
            Properties *[]SchemaPropertyType `json:"properties,omitempty"`
            Labels map[string]*string `json:"labels"`
            Query *string `json:"query,omitempty"`
            ConnectionID *string `json:"connectionId,omitempty"`
            ProfilingJobID *string `json:"profilingJobId,omitempty"`
            HasProfile *bool `json:"hasProfile,omitempty"`
            PublisherMetaJSON *string `json:"publisherMetaJson,omitempty"`
            // Capability - Possible values include: 'SchemaCapabilityEnumRead', 'SchemaCapabilityEnumWrite', 'SchemaCapabilityEnumReadWrite', 'SchemaCapabilityEnumQualityCheck'
            Capability SchemaCapabilityEnum `json:"capability,omitempty"`
            Form *SchemaFormType `json:"form,omitempty"`
            TemplateDimensions map[string]*string `json:"templateDimensions"`
            CreatedAt *date.Time `json:"createdAt,omitempty"`
            CreatedBy *string `json:"createdBy,omitempty"`
            UpdatedAt *date.Time `json:"updatedAt,omitempty"`
            UpdatedBy *string `json:"updatedBy,omitempty"`
            DeletedAt *date.Time `json:"deletedAt,omitempty"`
            DeletedBy *string `json:"deletedBy,omitempty"`
            }

        // MarshalJSON is the custom marshaler for SchemaType.
        func (st SchemaType)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(st.ID != nil) {
                objectMap["id"] = st.ID
                }
                if(st.Version != nil) {
                objectMap["version"] = st.Version
                }
                if(st.Name != nil) {
                objectMap["name"] = st.Name
                }
                if(st.Description != nil) {
                objectMap["description"] = st.Description
                }
                if(st.DiscoveredID != nil) {
                objectMap["discoveredId"] = st.DiscoveredID
                }
                if(st.DiscoveredName != nil) {
                objectMap["discoveredName"] = st.DiscoveredName
                }
                if(st.DiscoveredDescription != nil) {
                objectMap["discoveredDescription"] = st.DiscoveredDescription
                }
                if(st.IsUserDefined != nil) {
                objectMap["isUserDefined"] = st.IsUserDefined
                }
                if(st.Properties != nil) {
                objectMap["properties"] = st.Properties
                }
                if(st.Labels != nil) {
                objectMap["labels"] = st.Labels
                }
                if(st.Query != nil) {
                objectMap["query"] = st.Query
                }
                if(st.ConnectionID != nil) {
                objectMap["connectionId"] = st.ConnectionID
                }
                if(st.ProfilingJobID != nil) {
                objectMap["profilingJobId"] = st.ProfilingJobID
                }
                if(st.HasProfile != nil) {
                objectMap["hasProfile"] = st.HasProfile
                }
                if(st.PublisherMetaJSON != nil) {
                objectMap["publisherMetaJson"] = st.PublisherMetaJSON
                }
                if(st.Capability != "") {
                objectMap["capability"] = st.Capability
                }
                if(st.Form != nil) {
                objectMap["form"] = st.Form
                }
                if(st.TemplateDimensions != nil) {
                objectMap["templateDimensions"] = st.TemplateDimensions
                }
                if(st.CreatedAt != nil) {
                objectMap["createdAt"] = st.CreatedAt
                }
                if(st.CreatedBy != nil) {
                objectMap["createdBy"] = st.CreatedBy
                }
                if(st.UpdatedAt != nil) {
                objectMap["updatedAt"] = st.UpdatedAt
                }
                if(st.UpdatedBy != nil) {
                objectMap["updatedBy"] = st.UpdatedBy
                }
                if(st.DeletedAt != nil) {
                objectMap["deletedAt"] = st.DeletedAt
                }
                if(st.DeletedBy != nil) {
                objectMap["deletedBy"] = st.DeletedBy
                }
                return json.Marshal(objectMap)
        }

            // SetListStringType ...
            type SetListStringType struct {
            autorest.Response `json:"-"`
            Value map[string][]string `json:"value"`
            }

        // MarshalJSON is the custom marshaler for SetListStringType.
        func (slst SetListStringType)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(slst.Value != nil) {
                objectMap["value"] = slst.Value
                }
                return json.Marshal(objectMap)
        }

            // SetObjectType ...
            type SetObjectType struct {
            autorest.Response `json:"-"`
            Value interface{} `json:"value,omitempty"`
            }

            // ShapePropertySecurityType ...
            type ShapePropertySecurityType struct {
            // Algorithm - Possible values include: 'None', 'Aesgcm', 'Sha256Hmac'
            Algorithm SecurityAlgorithmEnum `json:"algorithm,omitempty"`
            // KeyStorage - Possible values include: 'Vault', 'File'
            KeyStorage SecurityKeyStorageEnum `json:"keyStorage,omitempty"`
            Key *string `json:"key,omitempty"`
            }

            // ShapePropertyType ...
            type ShapePropertyType struct {
            ID *string `json:"id,omitempty"`
            Name *string `json:"name,omitempty"`
            Description *string `json:"description,omitempty"`
            // Type - Possible values include: 'String', 'Bool', 'Integer', 'Float', 'Decimal', 'Date', 'Time', 'Datetime', 'Text', 'Blob', 'JSON'
            Type PropertyTypeEnum `json:"type,omitempty"`
            IsUnique *bool `json:"isUnique,omitempty"`
            Security *ShapePropertySecurityType `json:"security,omitempty"`
            IsNullable *bool `json:"isNullable,omitempty"`
            IsHidden *bool `json:"isHidden,omitempty"`
            }

            // ShapeType ...
            type ShapeType struct {
            autorest.Response `json:"-"`
            ID *string `json:"id,omitempty"`
            Version *int32 `json:"version,omitempty"`
            Name *string `json:"name,omitempty"`
            Description *string `json:"description,omitempty"`
            Properties *[]ShapePropertyType `json:"properties,omitempty"`
            Labels map[string]*string `json:"labels"`
            IsMdmShape *bool `json:"isMdmShape,omitempty"`
            MatchRule *MatchRuleType `json:"matchRule,omitempty"`
            MergeRule *MergeRuleType `json:"mergeRule,omitempty"`
            CopiedFromSchemaID *string `json:"copiedFromSchemaId,omitempty"`
            CreatedAt *date.Time `json:"createdAt,omitempty"`
            CreatedBy *string `json:"createdBy,omitempty"`
            UpdatedAt *date.Time `json:"updatedAt,omitempty"`
            UpdatedBy *string `json:"updatedBy,omitempty"`
            DeletedAt *date.Time `json:"deletedAt,omitempty"`
            DeletedBy *string `json:"deletedBy,omitempty"`
            }

        // MarshalJSON is the custom marshaler for ShapeType.
        func (st ShapeType)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(st.ID != nil) {
                objectMap["id"] = st.ID
                }
                if(st.Version != nil) {
                objectMap["version"] = st.Version
                }
                if(st.Name != nil) {
                objectMap["name"] = st.Name
                }
                if(st.Description != nil) {
                objectMap["description"] = st.Description
                }
                if(st.Properties != nil) {
                objectMap["properties"] = st.Properties
                }
                if(st.Labels != nil) {
                objectMap["labels"] = st.Labels
                }
                if(st.IsMdmShape != nil) {
                objectMap["isMdmShape"] = st.IsMdmShape
                }
                if(st.MatchRule != nil) {
                objectMap["matchRule"] = st.MatchRule
                }
                if(st.MergeRule != nil) {
                objectMap["mergeRule"] = st.MergeRule
                }
                if(st.CopiedFromSchemaID != nil) {
                objectMap["copiedFromSchemaId"] = st.CopiedFromSchemaID
                }
                if(st.CreatedAt != nil) {
                objectMap["createdAt"] = st.CreatedAt
                }
                if(st.CreatedBy != nil) {
                objectMap["createdBy"] = st.CreatedBy
                }
                if(st.UpdatedAt != nil) {
                objectMap["updatedAt"] = st.UpdatedAt
                }
                if(st.UpdatedBy != nil) {
                objectMap["updatedBy"] = st.UpdatedBy
                }
                if(st.DeletedAt != nil) {
                objectMap["deletedAt"] = st.DeletedAt
                }
                if(st.DeletedBy != nil) {
                objectMap["deletedBy"] = st.DeletedBy
                }
                return json.Marshal(objectMap)
        }

            // TraceType ...
            type TraceType struct {
            N *string `json:"n,omitempty"`
            Ts *date.Time `json:"ts,omitempty"`
            D *int32 `json:"d,omitempty"`
            }

            // TraitAttributeDefinitionType ...
            type TraitAttributeDefinitionType struct {
            ID *string `json:"id,omitempty"`
            Name *string `json:"name,omitempty"`
            // Type - Possible values include: 'TraitAttributeTypeEnumString', 'TraitAttributeTypeEnumCount', 'TraitAttributeTypeEnumPercent', 'TraitAttributeTypeEnumStatistic', 'TraitAttributeTypeEnumDetails', 'TraitAttributeTypeEnumHistogram', 'TraitAttributeTypeEnumBoxplot'
            Type TraitAttributeTypeEnum `json:"type,omitempty"`
            }

            // TraitDefinitionType ...
            type TraitDefinitionType struct {
            ID *string `json:"id,omitempty"`
            Name *string `json:"name,omitempty"`
            Family *string `json:"family,omitempty"`
            Order *int32 `json:"order,omitempty"`
            Description *string `json:"description,omitempty"`
            Help *string `json:"help,omitempty"`
            Attributes *[]TraitAttributeDefinitionType `json:"attributes,omitempty"`
            }

            // TransformType ...
            type TransformType struct {
            TransformID *string `json:"transformId,omitempty"`
            Format *string `json:"format,omitempty"`
            }

            // WritebackType ...
            type WritebackType struct {
            WritebackID *string `json:"writebackId,omitempty"`
            }

