/**
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

package com.naveego.metabase.implementation;

import com.naveego.metabase.MetabaseAPI10;
import com.microsoft.rest.ServiceClient;
import com.microsoft.rest.RestClient;
import okhttp3.OkHttpClient;
import retrofit2.Retrofit;
import com.google.common.reflect.TypeToken;
import com.microsoft.rest.RestException;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.Validator;
import com.naveego.metabase.models.Batch;
import com.naveego.metabase.models.BatchStatusGoBetweenScope;
import com.naveego.metabase.models.Connection;
import com.naveego.metabase.models.DataflowEvent;
import com.naveego.metabase.models.Flow;
import com.naveego.metabase.models.Job;
import com.naveego.metabase.models.JobStatusGoBetweenScope;
import com.naveego.metabase.models.Mapping;
import com.naveego.metabase.models.PagedResultOfBatchStatus;
import com.naveego.metabase.models.PagedResultOfJobStatus;
import com.naveego.metabase.models.RealTimeStateScope;
import com.naveego.metabase.models.Schema;
import com.naveego.metabase.models.SchemaProfile;
import com.naveego.metabase.models.Shape;
import java.io.IOException;
import java.util.List;
import java.util.Map;
import okhttp3.ResponseBody;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Headers;
import retrofit2.http.HTTP;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.http.PUT;
import retrofit2.http.Query;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * Initializes a new instance of the MetabaseAPI10 class.
 */
public class MetabaseAPI10Impl extends ServiceClient implements MetabaseAPI10 {
    /**
     * The Retrofit service to perform REST calls.
     */
    private MetabaseAPI10Service service;

    /**
     * Initializes an instance of MetabaseAPI10 client.
     */
    public MetabaseAPI10Impl() {
        this("http://metabase.n5o.red");
    }

    /**
     * Initializes an instance of MetabaseAPI10 client.
     *
     * @param baseUrl the base URL of the host
     */
    public MetabaseAPI10Impl(String baseUrl) {
        super(baseUrl);
        initialize();
    }

    /**
     * Initializes an instance of MetabaseAPI10 client.
     *
     * @param clientBuilder the builder for building an OkHttp client, bundled with user configurations
     * @param restBuilder the builder for building an Retrofit client, bundled with user configurations
     */
    public MetabaseAPI10Impl(OkHttpClient.Builder clientBuilder, Retrofit.Builder restBuilder) {
        this("http://metabase.n5o.red", clientBuilder, restBuilder);
        initialize();
    }

    /**
     * Initializes an instance of MetabaseAPI10 client.
     *
     * @param baseUrl the base URL of the host
     * @param clientBuilder the builder for building an OkHttp client, bundled with user configurations
     * @param restBuilder the builder for building an Retrofit client, bundled with user configurations
     */
    public MetabaseAPI10Impl(String baseUrl, OkHttpClient.Builder clientBuilder, Retrofit.Builder restBuilder) {
        super(baseUrl, clientBuilder, restBuilder);
        initialize();
    }

    /**
     * Initializes an instance of MetabaseAPI10 client.
     *
     * @param restClient the REST client containing pre-configured settings
     */
    public MetabaseAPI10Impl(RestClient restClient) {
        super(restClient);
        initialize();
    }

    private void initialize() {
        initializeService();
    }

    private void initializeService() {
        service = retrofit().create(MetabaseAPI10Service.class);
    }

    /**
     * The interface defining all the services for MetabaseAPI10 to be
     * used by Retrofit to perform actually REST calls.
     */
    interface MetabaseAPI10Service {
        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.naveego.metabase.MetabaseAPI10 setBatchStatusForGoBetweenBatch" })
        @PUT("v1/batches/{id}/status/go-between-agent")
        Observable<Response<ResponseBody>> setBatchStatusForGoBetweenBatch(@Path("id") String id, @Body BatchStatusGoBetweenScope status);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.naveego.metabase.MetabaseAPI10 getPagedStatusesForBatch" })
        @GET("v1/batches/{id}/status")
        Observable<Response<ResponseBody>> getPagedStatusesForBatch(@Path("id") String id, @Query("page") Integer page, @Query("pageSize") Integer pageSize);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.naveego.metabase.MetabaseAPI10 eventsPlaceholderForBatch" })
        @GET("v1/batches/events")
        Observable<Response<ResponseBody>> eventsPlaceholderForBatch();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.naveego.metabase.MetabaseAPI10 getAllBatches" })
        @GET("v1/batches")
        Observable<Response<ResponseBody>> getAllBatches(@Query("id") String id, @Query("name") String name, @Query("description") String description, @Query("jobId") String jobId, @Query("createdBy") String createdBy, @Query("updatedBy") String updatedBy, @Query("deletedBy") String deletedBy);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.naveego.metabase.MetabaseAPI10 createBatch" })
        @POST("v1/batches")
        Observable<Response<ResponseBody>> createBatch(@Body Batch input);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.naveego.metabase.MetabaseAPI10 getOneBatch" })
        @GET("v1/batches/{id}")
        Observable<Response<ResponseBody>> getOneBatch(@Path("id") String id, @Query("version") Integer version);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.naveego.metabase.MetabaseAPI10 updateBatch" })
        @PUT("v1/batches/{id}")
        Observable<Response<ResponseBody>> updateBatch(@Path("id") String id, @Body Batch model);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.naveego.metabase.MetabaseAPI10 deleteBatch" })
        @HTTP(path = "v1/batches/{id}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteBatch(@Path("id") String id);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.naveego.metabase.MetabaseAPI10 getBatchVersions" })
        @GET("v1/batches/{id}/versions")
        Observable<Response<ResponseBody>> getBatchVersions(@Path("id") String id);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.naveego.metabase.MetabaseAPI10 getAllConnections" })
        @GET("v1/connections")
        Observable<Response<ResponseBody>> getAllConnections(@Query("id") String id, @Query("name") String name, @Query("description") String description, @Query("plugin") String plugin, @Query("preferredAgent") String preferredAgent, @Query("createdBy") String createdBy, @Query("updatedBy") String updatedBy, @Query("deletedBy") String deletedBy);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.naveego.metabase.MetabaseAPI10 createConnection" })
        @POST("v1/connections")
        Observable<Response<ResponseBody>> createConnection(@Body Connection input);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.naveego.metabase.MetabaseAPI10 getOneConnection" })
        @GET("v1/connections/{id}")
        Observable<Response<ResponseBody>> getOneConnection(@Path("id") String id, @Query("version") Integer version);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.naveego.metabase.MetabaseAPI10 updateConnection" })
        @PUT("v1/connections/{id}")
        Observable<Response<ResponseBody>> updateConnection(@Path("id") String id, @Body Connection model);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.naveego.metabase.MetabaseAPI10 deleteConnection" })
        @HTTP(path = "v1/connections/{id}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteConnection(@Path("id") String id);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.naveego.metabase.MetabaseAPI10 getConnectionVersions" })
        @GET("v1/connections/{id}/versions")
        Observable<Response<ResponseBody>> getConnectionVersions(@Path("id") String id);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.naveego.metabase.MetabaseAPI10 getAllFlows" })
        @GET("v1/flows")
        Observable<Response<ResponseBody>> getAllFlows(@Query("id") String id, @Query("name") String name, @Query("description") String description, @Query("createdBy") String createdBy, @Query("updatedBy") String updatedBy, @Query("deletedBy") String deletedBy);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.naveego.metabase.MetabaseAPI10 createFlow" })
        @POST("v1/flows")
        Observable<Response<ResponseBody>> createFlow(@Body Flow input);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.naveego.metabase.MetabaseAPI10 getOneFlow" })
        @GET("v1/flows/{id}")
        Observable<Response<ResponseBody>> getOneFlow(@Path("id") String id, @Query("version") Integer version);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.naveego.metabase.MetabaseAPI10 updateFlow" })
        @PUT("v1/flows/{id}")
        Observable<Response<ResponseBody>> updateFlow(@Path("id") String id, @Body Flow model);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.naveego.metabase.MetabaseAPI10 deleteFlow" })
        @HTTP(path = "v1/flows/{id}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteFlow(@Path("id") String id);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.naveego.metabase.MetabaseAPI10 getFlowVersions" })
        @GET("v1/flows/{id}/versions")
        Observable<Response<ResponseBody>> getFlowVersions(@Path("id") String id);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.naveego.metabase.MetabaseAPI10 getJobMapping" })
        @GET("v1/jobs/{id}/mapping")
        Observable<Response<ResponseBody>> getJobMapping(@Path("id") String id, @Query("version") Integer version);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.naveego.metabase.MetabaseAPI10 setJobStatusForGoBetween" })
        @PUT("v1/jobs/{id}/status/go-between")
        Observable<Response<ResponseBody>> setJobStatusForGoBetween(@Path("id") String id, @Body JobStatusGoBetweenScope status);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.naveego.metabase.MetabaseAPI10 setRealTimeState" })
        @PUT("v1/jobs/{id}/status/realtime")
        Observable<Response<ResponseBody>> setRealTimeState(@Path("id") String id, @Body RealTimeStateScope state);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.naveego.metabase.MetabaseAPI10 getAllJobs" })
        @GET("v1/jobs")
        Observable<Response<ResponseBody>> getAllJobs(@Query("id") String id, @Query("name") String name, @Query("description") String description, @Query("connectionId") String connectionId, @Query("schemaId") String schemaId, @Query("shapeId") String shapeId, @Query("agentId") String agentId, @Query("type") String type, @Query("createdBy") String createdBy, @Query("updatedBy") String updatedBy, @Query("deletedBy") String deletedBy);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.naveego.metabase.MetabaseAPI10 createJob" })
        @POST("v1/jobs")
        Observable<Response<ResponseBody>> createJob(@Body Job input);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.naveego.metabase.MetabaseAPI10 getPagedStatusesForJob" })
        @GET("v1/jobs/{id}/status")
        Observable<Response<ResponseBody>> getPagedStatusesForJob(@Path("id") String id, @Query("page") Integer page, @Query("pageSize") Integer pageSize);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.naveego.metabase.MetabaseAPI10 eventsPlaceholderForJob" })
        @GET("v1/jobs/events")
        Observable<Response<ResponseBody>> eventsPlaceholderForJob();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.naveego.metabase.MetabaseAPI10 getOneJob" })
        @GET("v1/jobs/{id}")
        Observable<Response<ResponseBody>> getOneJob(@Path("id") String id, @Query("version") Integer version);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.naveego.metabase.MetabaseAPI10 updateJob" })
        @PUT("v1/jobs/{id}")
        Observable<Response<ResponseBody>> updateJob(@Path("id") String id, @Body Job model);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.naveego.metabase.MetabaseAPI10 deleteJob" })
        @HTTP(path = "v1/jobs/{id}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteJob(@Path("id") String id);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.naveego.metabase.MetabaseAPI10 getJobVersions" })
        @GET("v1/jobs/{id}/versions")
        Observable<Response<ResponseBody>> getJobVersions(@Path("id") String id);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.naveego.metabase.MetabaseAPI10 getAllSchemaProfiles" })
        @GET("v1/schemaprofiles")
        Observable<Response<ResponseBody>> getAllSchemaProfiles(@Query("id") String id, @Query("name") String name, @Query("description") String description, @Query("connectionId") String connectionId, @Query("createdBy") String createdBy, @Query("updatedBy") String updatedBy, @Query("deletedBy") String deletedBy);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.naveego.metabase.MetabaseAPI10 createSchemaProfile" })
        @POST("v1/schemaprofiles")
        Observable<Response<ResponseBody>> createSchemaProfile(@Body SchemaProfile input);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.naveego.metabase.MetabaseAPI10 getOneSchemaProfile" })
        @GET("v1/schemaprofiles/{id}")
        Observable<Response<ResponseBody>> getOneSchemaProfile(@Path("id") String id, @Query("version") Integer version);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.naveego.metabase.MetabaseAPI10 updateSchemaProfile" })
        @PUT("v1/schemaprofiles/{id}")
        Observable<Response<ResponseBody>> updateSchemaProfile(@Path("id") String id, @Body SchemaProfile model);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.naveego.metabase.MetabaseAPI10 deleteSchemaProfile" })
        @HTTP(path = "v1/schemaprofiles/{id}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteSchemaProfile(@Path("id") String id);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.naveego.metabase.MetabaseAPI10 getSchemaProfileVersions" })
        @GET("v1/schemaprofiles/{id}/versions")
        Observable<Response<ResponseBody>> getSchemaProfileVersions(@Path("id") String id);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.naveego.metabase.MetabaseAPI10 getAllSchemas" })
        @GET("v1/schemas")
        Observable<Response<ResponseBody>> getAllSchemas(@Query("id") String id, @Query("name") String name, @Query("description") String description, @Query("discoveredId") String discoveredId, @Query("discoveredName") String discoveredName, @Query("discoveredDescription") String discoveredDescription, @Query("query") String query, @Query("connectionId") String connectionId, @Query("profilingJobId") String profilingJobId, @Query("publisherMetaJson") String publisherMetaJson, @Query("capability") String capability, @Query("createdBy") String createdBy, @Query("updatedBy") String updatedBy, @Query("deletedBy") String deletedBy);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.naveego.metabase.MetabaseAPI10 createSchema" })
        @POST("v1/schemas")
        Observable<Response<ResponseBody>> createSchema(@Body Schema input);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.naveego.metabase.MetabaseAPI10 getOneSchema" })
        @GET("v1/schemas/{id}")
        Observable<Response<ResponseBody>> getOneSchema(@Path("id") String id, @Query("version") Integer version);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.naveego.metabase.MetabaseAPI10 updateSchema" })
        @PUT("v1/schemas/{id}")
        Observable<Response<ResponseBody>> updateSchema(@Path("id") String id, @Body Schema model);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.naveego.metabase.MetabaseAPI10 deleteSchema" })
        @HTTP(path = "v1/schemas/{id}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteSchema(@Path("id") String id);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.naveego.metabase.MetabaseAPI10 getSchemaVersions" })
        @GET("v1/schemas/{id}/versions")
        Observable<Response<ResponseBody>> getSchemaVersions(@Path("id") String id);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.naveego.metabase.MetabaseAPI10 getAllShapes" })
        @GET("v1/shapes")
        Observable<Response<ResponseBody>> getAllShapes(@Query("id") String id, @Query("name") String name, @Query("description") String description, @Query("copiedFromSchemaId") String copiedFromSchemaId, @Query("createdBy") String createdBy, @Query("updatedBy") String updatedBy, @Query("deletedBy") String deletedBy);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.naveego.metabase.MetabaseAPI10 createShape" })
        @POST("v1/shapes")
        Observable<Response<ResponseBody>> createShape(@Body Shape input);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.naveego.metabase.MetabaseAPI10 getOneShape" })
        @GET("v1/shapes/{id}")
        Observable<Response<ResponseBody>> getOneShape(@Path("id") String id, @Query("version") Integer version);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.naveego.metabase.MetabaseAPI10 updateShape" })
        @PUT("v1/shapes/{id}")
        Observable<Response<ResponseBody>> updateShape(@Path("id") String id, @Body Shape model);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.naveego.metabase.MetabaseAPI10 deleteShape" })
        @HTTP(path = "v1/shapes/{id}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteShape(@Path("id") String id);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.naveego.metabase.MetabaseAPI10 getShapeVersions" })
        @GET("v1/shapes/{id}/versions")
        Observable<Response<ResponseBody>> getShapeVersions(@Path("id") String id);

    }

    /**
     * Set batch status for go between batch.
     *
     * @param id the String value
     * @param status the BatchStatusGoBetweenScope value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Map&lt;String, List&lt;String&gt;&gt; object if successful.
     */
    public Map<String, List<String>> setBatchStatusForGoBetweenBatch(String id, BatchStatusGoBetweenScope status) {
        return setBatchStatusForGoBetweenBatchWithServiceResponseAsync(id, status).toBlocking().single().body();
    }

    /**
     * Set batch status for go between batch.
     *
     * @param id the String value
     * @param status the BatchStatusGoBetweenScope value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Map<String, List<String>>> setBatchStatusForGoBetweenBatchAsync(String id, BatchStatusGoBetweenScope status, final ServiceCallback<Map<String, List<String>>> serviceCallback) {
        return ServiceFuture.fromResponse(setBatchStatusForGoBetweenBatchWithServiceResponseAsync(id, status), serviceCallback);
    }

    /**
     * Set batch status for go between batch.
     *
     * @param id the String value
     * @param status the BatchStatusGoBetweenScope value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Map&lt;String, List&lt;String&gt;&gt; object
     */
    public Observable<Map<String, List<String>>> setBatchStatusForGoBetweenBatchAsync(String id, BatchStatusGoBetweenScope status) {
        return setBatchStatusForGoBetweenBatchWithServiceResponseAsync(id, status).map(new Func1<ServiceResponse<Map<String, List<String>>>, Map<String, List<String>>>() {
            @Override
            public Map<String, List<String>> call(ServiceResponse<Map<String, List<String>>> response) {
                return response.body();
            }
        });
    }

    /**
     * Set batch status for go between batch.
     *
     * @param id the String value
     * @param status the BatchStatusGoBetweenScope value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Map&lt;String, List&lt;String&gt;&gt; object
     */
    public Observable<ServiceResponse<Map<String, List<String>>>> setBatchStatusForGoBetweenBatchWithServiceResponseAsync(String id, BatchStatusGoBetweenScope status) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (status == null) {
            throw new IllegalArgumentException("Parameter status is required and cannot be null.");
        }
        Validator.validate(status);
        return service.setBatchStatusForGoBetweenBatch(id, status)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Map<String, List<String>>>>>() {
                @Override
                public Observable<ServiceResponse<Map<String, List<String>>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Map<String, List<String>>> clientResponse = setBatchStatusForGoBetweenBatchDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Map<String, List<String>>> setBatchStatusForGoBetweenBatchDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Map<String, List<String>>, RestException>newInstance(this.serializerAdapter())
                .register(202, new TypeToken<Void>() { }.getType())
                .register(400, new TypeToken<Map<String, List<String>>>() { }.getType())
                .build(response);
    }

    /**
     * Get paged statuses for batch.
     *
     * @param id the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedResultOfBatchStatus object if successful.
     */
    public PagedResultOfBatchStatus getPagedStatusesForBatch(String id) {
        return getPagedStatusesForBatchWithServiceResponseAsync(id).toBlocking().single().body();
    }

    /**
     * Get paged statuses for batch.
     *
     * @param id the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PagedResultOfBatchStatus> getPagedStatusesForBatchAsync(String id, final ServiceCallback<PagedResultOfBatchStatus> serviceCallback) {
        return ServiceFuture.fromResponse(getPagedStatusesForBatchWithServiceResponseAsync(id), serviceCallback);
    }

    /**
     * Get paged statuses for batch.
     *
     * @param id the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedResultOfBatchStatus object
     */
    public Observable<PagedResultOfBatchStatus> getPagedStatusesForBatchAsync(String id) {
        return getPagedStatusesForBatchWithServiceResponseAsync(id).map(new Func1<ServiceResponse<PagedResultOfBatchStatus>, PagedResultOfBatchStatus>() {
            @Override
            public PagedResultOfBatchStatus call(ServiceResponse<PagedResultOfBatchStatus> response) {
                return response.body();
            }
        });
    }

    /**
     * Get paged statuses for batch.
     *
     * @param id the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedResultOfBatchStatus object
     */
    public Observable<ServiceResponse<PagedResultOfBatchStatus>> getPagedStatusesForBatchWithServiceResponseAsync(String id) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        final Integer page = null;
        final Integer pageSize = null;
        return service.getPagedStatusesForBatch(id, page, pageSize)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PagedResultOfBatchStatus>>>() {
                @Override
                public Observable<ServiceResponse<PagedResultOfBatchStatus>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PagedResultOfBatchStatus> clientResponse = getPagedStatusesForBatchDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get paged statuses for batch.
     *
     * @param id the String value
     * @param page the Integer value
     * @param pageSize the Integer value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedResultOfBatchStatus object if successful.
     */
    public PagedResultOfBatchStatus getPagedStatusesForBatch(String id, Integer page, Integer pageSize) {
        return getPagedStatusesForBatchWithServiceResponseAsync(id, page, pageSize).toBlocking().single().body();
    }

    /**
     * Get paged statuses for batch.
     *
     * @param id the String value
     * @param page the Integer value
     * @param pageSize the Integer value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PagedResultOfBatchStatus> getPagedStatusesForBatchAsync(String id, Integer page, Integer pageSize, final ServiceCallback<PagedResultOfBatchStatus> serviceCallback) {
        return ServiceFuture.fromResponse(getPagedStatusesForBatchWithServiceResponseAsync(id, page, pageSize), serviceCallback);
    }

    /**
     * Get paged statuses for batch.
     *
     * @param id the String value
     * @param page the Integer value
     * @param pageSize the Integer value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedResultOfBatchStatus object
     */
    public Observable<PagedResultOfBatchStatus> getPagedStatusesForBatchAsync(String id, Integer page, Integer pageSize) {
        return getPagedStatusesForBatchWithServiceResponseAsync(id, page, pageSize).map(new Func1<ServiceResponse<PagedResultOfBatchStatus>, PagedResultOfBatchStatus>() {
            @Override
            public PagedResultOfBatchStatus call(ServiceResponse<PagedResultOfBatchStatus> response) {
                return response.body();
            }
        });
    }

    /**
     * Get paged statuses for batch.
     *
     * @param id the String value
     * @param page the Integer value
     * @param pageSize the Integer value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedResultOfBatchStatus object
     */
    public Observable<ServiceResponse<PagedResultOfBatchStatus>> getPagedStatusesForBatchWithServiceResponseAsync(String id, Integer page, Integer pageSize) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        return service.getPagedStatusesForBatch(id, page, pageSize)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PagedResultOfBatchStatus>>>() {
                @Override
                public Observable<ServiceResponse<PagedResultOfBatchStatus>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PagedResultOfBatchStatus> clientResponse = getPagedStatusesForBatchDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PagedResultOfBatchStatus> getPagedStatusesForBatchDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<PagedResultOfBatchStatus, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<PagedResultOfBatchStatus>() { }.getType())
                .build(response);
    }

    /**
     * Events placeholder for batch.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the DataflowEvent object if successful.
     */
    public DataflowEvent eventsPlaceholderForBatch() {
        return eventsPlaceholderForBatchWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Events placeholder for batch.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<DataflowEvent> eventsPlaceholderForBatchAsync(final ServiceCallback<DataflowEvent> serviceCallback) {
        return ServiceFuture.fromResponse(eventsPlaceholderForBatchWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Events placeholder for batch.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DataflowEvent object
     */
    public Observable<DataflowEvent> eventsPlaceholderForBatchAsync() {
        return eventsPlaceholderForBatchWithServiceResponseAsync().map(new Func1<ServiceResponse<DataflowEvent>, DataflowEvent>() {
            @Override
            public DataflowEvent call(ServiceResponse<DataflowEvent> response) {
                return response.body();
            }
        });
    }

    /**
     * Events placeholder for batch.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DataflowEvent object
     */
    public Observable<ServiceResponse<DataflowEvent>> eventsPlaceholderForBatchWithServiceResponseAsync() {
        return service.eventsPlaceholderForBatch()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<DataflowEvent>>>() {
                @Override
                public Observable<ServiceResponse<DataflowEvent>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<DataflowEvent> clientResponse = eventsPlaceholderForBatchDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<DataflowEvent> eventsPlaceholderForBatchDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<DataflowEvent, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<DataflowEvent>() { }.getType())
                .build(response);
    }

    /**
     * Get all batches.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;Batch&gt; object if successful.
     */
    public List<Batch> getAllBatches() {
        return getAllBatchesWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Get all batches.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<Batch>> getAllBatchesAsync(final ServiceCallback<List<Batch>> serviceCallback) {
        return ServiceFuture.fromResponse(getAllBatchesWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get all batches.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Batch&gt; object
     */
    public Observable<List<Batch>> getAllBatchesAsync() {
        return getAllBatchesWithServiceResponseAsync().map(new Func1<ServiceResponse<List<Batch>>, List<Batch>>() {
            @Override
            public List<Batch> call(ServiceResponse<List<Batch>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get all batches.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Batch&gt; object
     */
    public Observable<ServiceResponse<List<Batch>>> getAllBatchesWithServiceResponseAsync() {
        final String id = null;
        final String name = null;
        final String description = null;
        final String jobId = null;
        final String createdBy = null;
        final String updatedBy = null;
        final String deletedBy = null;
        return service.getAllBatches(id, name, description, jobId, createdBy, updatedBy, deletedBy)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<Batch>>>>() {
                @Override
                public Observable<ServiceResponse<List<Batch>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<Batch>> clientResponse = getAllBatchesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get all batches.
     *
     * @param id the String value
     * @param name the String value
     * @param description the String value
     * @param jobId the String value
     * @param createdBy the String value
     * @param updatedBy the String value
     * @param deletedBy the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;Batch&gt; object if successful.
     */
    public List<Batch> getAllBatches(String id, String name, String description, String jobId, String createdBy, String updatedBy, String deletedBy) {
        return getAllBatchesWithServiceResponseAsync(id, name, description, jobId, createdBy, updatedBy, deletedBy).toBlocking().single().body();
    }

    /**
     * Get all batches.
     *
     * @param id the String value
     * @param name the String value
     * @param description the String value
     * @param jobId the String value
     * @param createdBy the String value
     * @param updatedBy the String value
     * @param deletedBy the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<Batch>> getAllBatchesAsync(String id, String name, String description, String jobId, String createdBy, String updatedBy, String deletedBy, final ServiceCallback<List<Batch>> serviceCallback) {
        return ServiceFuture.fromResponse(getAllBatchesWithServiceResponseAsync(id, name, description, jobId, createdBy, updatedBy, deletedBy), serviceCallback);
    }

    /**
     * Get all batches.
     *
     * @param id the String value
     * @param name the String value
     * @param description the String value
     * @param jobId the String value
     * @param createdBy the String value
     * @param updatedBy the String value
     * @param deletedBy the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Batch&gt; object
     */
    public Observable<List<Batch>> getAllBatchesAsync(String id, String name, String description, String jobId, String createdBy, String updatedBy, String deletedBy) {
        return getAllBatchesWithServiceResponseAsync(id, name, description, jobId, createdBy, updatedBy, deletedBy).map(new Func1<ServiceResponse<List<Batch>>, List<Batch>>() {
            @Override
            public List<Batch> call(ServiceResponse<List<Batch>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get all batches.
     *
     * @param id the String value
     * @param name the String value
     * @param description the String value
     * @param jobId the String value
     * @param createdBy the String value
     * @param updatedBy the String value
     * @param deletedBy the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Batch&gt; object
     */
    public Observable<ServiceResponse<List<Batch>>> getAllBatchesWithServiceResponseAsync(String id, String name, String description, String jobId, String createdBy, String updatedBy, String deletedBy) {
        return service.getAllBatches(id, name, description, jobId, createdBy, updatedBy, deletedBy)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<Batch>>>>() {
                @Override
                public Observable<ServiceResponse<List<Batch>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<Batch>> clientResponse = getAllBatchesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<Batch>> getAllBatchesDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<List<Batch>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<Batch>>() { }.getType())
                .build(response);
    }

    /**
     * Create batch.
     *
     * @param input the Batch value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object createBatch(Batch input) {
        return createBatchWithServiceResponseAsync(input).toBlocking().single().body();
    }

    /**
     * Create batch.
     *
     * @param input the Batch value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> createBatchAsync(Batch input, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(createBatchWithServiceResponseAsync(input), serviceCallback);
    }

    /**
     * Create batch.
     *
     * @param input the Batch value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> createBatchAsync(Batch input) {
        return createBatchWithServiceResponseAsync(input).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Create batch.
     *
     * @param input the Batch value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> createBatchWithServiceResponseAsync(Batch input) {
        if (input == null) {
            throw new IllegalArgumentException("Parameter input is required and cannot be null.");
        }
        Validator.validate(input);
        return service.createBatch(input)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = createBatchDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> createBatchDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(201, new TypeToken<Batch>() { }.getType())
                .register(400, new TypeToken<Map<String, List<String>>>() { }.getType())
                .build(response);
    }

    /**
     * Get one batch.
     *
     * @param id the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Batch object if successful.
     */
    public Batch getOneBatch(String id) {
        return getOneBatchWithServiceResponseAsync(id).toBlocking().single().body();
    }

    /**
     * Get one batch.
     *
     * @param id the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Batch> getOneBatchAsync(String id, final ServiceCallback<Batch> serviceCallback) {
        return ServiceFuture.fromResponse(getOneBatchWithServiceResponseAsync(id), serviceCallback);
    }

    /**
     * Get one batch.
     *
     * @param id the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Batch object
     */
    public Observable<Batch> getOneBatchAsync(String id) {
        return getOneBatchWithServiceResponseAsync(id).map(new Func1<ServiceResponse<Batch>, Batch>() {
            @Override
            public Batch call(ServiceResponse<Batch> response) {
                return response.body();
            }
        });
    }

    /**
     * Get one batch.
     *
     * @param id the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Batch object
     */
    public Observable<ServiceResponse<Batch>> getOneBatchWithServiceResponseAsync(String id) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        final Integer version = null;
        return service.getOneBatch(id, version)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Batch>>>() {
                @Override
                public Observable<ServiceResponse<Batch>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Batch> clientResponse = getOneBatchDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get one batch.
     *
     * @param id the String value
     * @param version the Integer value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Batch object if successful.
     */
    public Batch getOneBatch(String id, Integer version) {
        return getOneBatchWithServiceResponseAsync(id, version).toBlocking().single().body();
    }

    /**
     * Get one batch.
     *
     * @param id the String value
     * @param version the Integer value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Batch> getOneBatchAsync(String id, Integer version, final ServiceCallback<Batch> serviceCallback) {
        return ServiceFuture.fromResponse(getOneBatchWithServiceResponseAsync(id, version), serviceCallback);
    }

    /**
     * Get one batch.
     *
     * @param id the String value
     * @param version the Integer value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Batch object
     */
    public Observable<Batch> getOneBatchAsync(String id, Integer version) {
        return getOneBatchWithServiceResponseAsync(id, version).map(new Func1<ServiceResponse<Batch>, Batch>() {
            @Override
            public Batch call(ServiceResponse<Batch> response) {
                return response.body();
            }
        });
    }

    /**
     * Get one batch.
     *
     * @param id the String value
     * @param version the Integer value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Batch object
     */
    public Observable<ServiceResponse<Batch>> getOneBatchWithServiceResponseAsync(String id, Integer version) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        return service.getOneBatch(id, version)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Batch>>>() {
                @Override
                public Observable<ServiceResponse<Batch>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Batch> clientResponse = getOneBatchDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Batch> getOneBatchDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Batch, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Batch>() { }.getType())
                .build(response);
    }

    /**
     * Update batch.
     *
     * @param id the String value
     * @param model the Batch value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object updateBatch(String id, Batch model) {
        return updateBatchWithServiceResponseAsync(id, model).toBlocking().single().body();
    }

    /**
     * Update batch.
     *
     * @param id the String value
     * @param model the Batch value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> updateBatchAsync(String id, Batch model, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(updateBatchWithServiceResponseAsync(id, model), serviceCallback);
    }

    /**
     * Update batch.
     *
     * @param id the String value
     * @param model the Batch value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> updateBatchAsync(String id, Batch model) {
        return updateBatchWithServiceResponseAsync(id, model).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Update batch.
     *
     * @param id the String value
     * @param model the Batch value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> updateBatchWithServiceResponseAsync(String id, Batch model) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (model == null) {
            throw new IllegalArgumentException("Parameter model is required and cannot be null.");
        }
        Validator.validate(model);
        return service.updateBatch(id, model)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = updateBatchDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> updateBatchDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(202, new TypeToken<Batch>() { }.getType())
                .register(400, new TypeToken<Map<String, List<String>>>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .register(409, new TypeToken<Batch>() { }.getType())
                .build(response);
    }

    /**
     * Delete batch.
     *
     * @param id the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteBatch(String id) {
        deleteBatchWithServiceResponseAsync(id).toBlocking().single().body();
    }

    /**
     * Delete batch.
     *
     * @param id the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteBatchAsync(String id, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteBatchWithServiceResponseAsync(id), serviceCallback);
    }

    /**
     * Delete batch.
     *
     * @param id the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteBatchAsync(String id) {
        return deleteBatchWithServiceResponseAsync(id).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete batch.
     *
     * @param id the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteBatchWithServiceResponseAsync(String id) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        return service.deleteBatch(id)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteBatchDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteBatchDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Get batch versions.
     *
     * @param id the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;Batch&gt; object if successful.
     */
    public List<Batch> getBatchVersions(String id) {
        return getBatchVersionsWithServiceResponseAsync(id).toBlocking().single().body();
    }

    /**
     * Get batch versions.
     *
     * @param id the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<Batch>> getBatchVersionsAsync(String id, final ServiceCallback<List<Batch>> serviceCallback) {
        return ServiceFuture.fromResponse(getBatchVersionsWithServiceResponseAsync(id), serviceCallback);
    }

    /**
     * Get batch versions.
     *
     * @param id the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Batch&gt; object
     */
    public Observable<List<Batch>> getBatchVersionsAsync(String id) {
        return getBatchVersionsWithServiceResponseAsync(id).map(new Func1<ServiceResponse<List<Batch>>, List<Batch>>() {
            @Override
            public List<Batch> call(ServiceResponse<List<Batch>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get batch versions.
     *
     * @param id the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Batch&gt; object
     */
    public Observable<ServiceResponse<List<Batch>>> getBatchVersionsWithServiceResponseAsync(String id) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        return service.getBatchVersions(id)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<Batch>>>>() {
                @Override
                public Observable<ServiceResponse<List<Batch>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<Batch>> clientResponse = getBatchVersionsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<Batch>> getBatchVersionsDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<List<Batch>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<Batch>>() { }.getType())
                .build(response);
    }

    /**
     * Get all connections.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;Connection&gt; object if successful.
     */
    public List<Connection> getAllConnections() {
        return getAllConnectionsWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Get all connections.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<Connection>> getAllConnectionsAsync(final ServiceCallback<List<Connection>> serviceCallback) {
        return ServiceFuture.fromResponse(getAllConnectionsWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get all connections.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Connection&gt; object
     */
    public Observable<List<Connection>> getAllConnectionsAsync() {
        return getAllConnectionsWithServiceResponseAsync().map(new Func1<ServiceResponse<List<Connection>>, List<Connection>>() {
            @Override
            public List<Connection> call(ServiceResponse<List<Connection>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get all connections.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Connection&gt; object
     */
    public Observable<ServiceResponse<List<Connection>>> getAllConnectionsWithServiceResponseAsync() {
        final String id = null;
        final String name = null;
        final String description = null;
        final String plugin = null;
        final String preferredAgent = null;
        final String createdBy = null;
        final String updatedBy = null;
        final String deletedBy = null;
        return service.getAllConnections(id, name, description, plugin, preferredAgent, createdBy, updatedBy, deletedBy)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<Connection>>>>() {
                @Override
                public Observable<ServiceResponse<List<Connection>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<Connection>> clientResponse = getAllConnectionsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get all connections.
     *
     * @param id the String value
     * @param name the String value
     * @param description the String value
     * @param plugin the String value
     * @param preferredAgent the String value
     * @param createdBy the String value
     * @param updatedBy the String value
     * @param deletedBy the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;Connection&gt; object if successful.
     */
    public List<Connection> getAllConnections(String id, String name, String description, String plugin, String preferredAgent, String createdBy, String updatedBy, String deletedBy) {
        return getAllConnectionsWithServiceResponseAsync(id, name, description, plugin, preferredAgent, createdBy, updatedBy, deletedBy).toBlocking().single().body();
    }

    /**
     * Get all connections.
     *
     * @param id the String value
     * @param name the String value
     * @param description the String value
     * @param plugin the String value
     * @param preferredAgent the String value
     * @param createdBy the String value
     * @param updatedBy the String value
     * @param deletedBy the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<Connection>> getAllConnectionsAsync(String id, String name, String description, String plugin, String preferredAgent, String createdBy, String updatedBy, String deletedBy, final ServiceCallback<List<Connection>> serviceCallback) {
        return ServiceFuture.fromResponse(getAllConnectionsWithServiceResponseAsync(id, name, description, plugin, preferredAgent, createdBy, updatedBy, deletedBy), serviceCallback);
    }

    /**
     * Get all connections.
     *
     * @param id the String value
     * @param name the String value
     * @param description the String value
     * @param plugin the String value
     * @param preferredAgent the String value
     * @param createdBy the String value
     * @param updatedBy the String value
     * @param deletedBy the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Connection&gt; object
     */
    public Observable<List<Connection>> getAllConnectionsAsync(String id, String name, String description, String plugin, String preferredAgent, String createdBy, String updatedBy, String deletedBy) {
        return getAllConnectionsWithServiceResponseAsync(id, name, description, plugin, preferredAgent, createdBy, updatedBy, deletedBy).map(new Func1<ServiceResponse<List<Connection>>, List<Connection>>() {
            @Override
            public List<Connection> call(ServiceResponse<List<Connection>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get all connections.
     *
     * @param id the String value
     * @param name the String value
     * @param description the String value
     * @param plugin the String value
     * @param preferredAgent the String value
     * @param createdBy the String value
     * @param updatedBy the String value
     * @param deletedBy the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Connection&gt; object
     */
    public Observable<ServiceResponse<List<Connection>>> getAllConnectionsWithServiceResponseAsync(String id, String name, String description, String plugin, String preferredAgent, String createdBy, String updatedBy, String deletedBy) {
        return service.getAllConnections(id, name, description, plugin, preferredAgent, createdBy, updatedBy, deletedBy)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<Connection>>>>() {
                @Override
                public Observable<ServiceResponse<List<Connection>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<Connection>> clientResponse = getAllConnectionsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<Connection>> getAllConnectionsDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<List<Connection>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<Connection>>() { }.getType())
                .build(response);
    }

    /**
     * Create connection.
     *
     * @param input the Connection value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object createConnection(Connection input) {
        return createConnectionWithServiceResponseAsync(input).toBlocking().single().body();
    }

    /**
     * Create connection.
     *
     * @param input the Connection value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> createConnectionAsync(Connection input, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(createConnectionWithServiceResponseAsync(input), serviceCallback);
    }

    /**
     * Create connection.
     *
     * @param input the Connection value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> createConnectionAsync(Connection input) {
        return createConnectionWithServiceResponseAsync(input).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Create connection.
     *
     * @param input the Connection value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> createConnectionWithServiceResponseAsync(Connection input) {
        if (input == null) {
            throw new IllegalArgumentException("Parameter input is required and cannot be null.");
        }
        Validator.validate(input);
        return service.createConnection(input)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = createConnectionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> createConnectionDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(201, new TypeToken<Connection>() { }.getType())
                .register(400, new TypeToken<Map<String, List<String>>>() { }.getType())
                .build(response);
    }

    /**
     * Get one connection.
     *
     * @param id the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Connection object if successful.
     */
    public Connection getOneConnection(String id) {
        return getOneConnectionWithServiceResponseAsync(id).toBlocking().single().body();
    }

    /**
     * Get one connection.
     *
     * @param id the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Connection> getOneConnectionAsync(String id, final ServiceCallback<Connection> serviceCallback) {
        return ServiceFuture.fromResponse(getOneConnectionWithServiceResponseAsync(id), serviceCallback);
    }

    /**
     * Get one connection.
     *
     * @param id the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Connection object
     */
    public Observable<Connection> getOneConnectionAsync(String id) {
        return getOneConnectionWithServiceResponseAsync(id).map(new Func1<ServiceResponse<Connection>, Connection>() {
            @Override
            public Connection call(ServiceResponse<Connection> response) {
                return response.body();
            }
        });
    }

    /**
     * Get one connection.
     *
     * @param id the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Connection object
     */
    public Observable<ServiceResponse<Connection>> getOneConnectionWithServiceResponseAsync(String id) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        final Integer version = null;
        return service.getOneConnection(id, version)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Connection>>>() {
                @Override
                public Observable<ServiceResponse<Connection>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Connection> clientResponse = getOneConnectionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get one connection.
     *
     * @param id the String value
     * @param version the Integer value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Connection object if successful.
     */
    public Connection getOneConnection(String id, Integer version) {
        return getOneConnectionWithServiceResponseAsync(id, version).toBlocking().single().body();
    }

    /**
     * Get one connection.
     *
     * @param id the String value
     * @param version the Integer value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Connection> getOneConnectionAsync(String id, Integer version, final ServiceCallback<Connection> serviceCallback) {
        return ServiceFuture.fromResponse(getOneConnectionWithServiceResponseAsync(id, version), serviceCallback);
    }

    /**
     * Get one connection.
     *
     * @param id the String value
     * @param version the Integer value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Connection object
     */
    public Observable<Connection> getOneConnectionAsync(String id, Integer version) {
        return getOneConnectionWithServiceResponseAsync(id, version).map(new Func1<ServiceResponse<Connection>, Connection>() {
            @Override
            public Connection call(ServiceResponse<Connection> response) {
                return response.body();
            }
        });
    }

    /**
     * Get one connection.
     *
     * @param id the String value
     * @param version the Integer value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Connection object
     */
    public Observable<ServiceResponse<Connection>> getOneConnectionWithServiceResponseAsync(String id, Integer version) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        return service.getOneConnection(id, version)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Connection>>>() {
                @Override
                public Observable<ServiceResponse<Connection>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Connection> clientResponse = getOneConnectionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Connection> getOneConnectionDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Connection, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Connection>() { }.getType())
                .build(response);
    }

    /**
     * Update connection.
     *
     * @param id the String value
     * @param model the Connection value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object updateConnection(String id, Connection model) {
        return updateConnectionWithServiceResponseAsync(id, model).toBlocking().single().body();
    }

    /**
     * Update connection.
     *
     * @param id the String value
     * @param model the Connection value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> updateConnectionAsync(String id, Connection model, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(updateConnectionWithServiceResponseAsync(id, model), serviceCallback);
    }

    /**
     * Update connection.
     *
     * @param id the String value
     * @param model the Connection value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> updateConnectionAsync(String id, Connection model) {
        return updateConnectionWithServiceResponseAsync(id, model).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Update connection.
     *
     * @param id the String value
     * @param model the Connection value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> updateConnectionWithServiceResponseAsync(String id, Connection model) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (model == null) {
            throw new IllegalArgumentException("Parameter model is required and cannot be null.");
        }
        Validator.validate(model);
        return service.updateConnection(id, model)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = updateConnectionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> updateConnectionDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(202, new TypeToken<Connection>() { }.getType())
                .register(400, new TypeToken<Map<String, List<String>>>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .register(409, new TypeToken<Connection>() { }.getType())
                .build(response);
    }

    /**
     * Delete connection.
     *
     * @param id the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteConnection(String id) {
        deleteConnectionWithServiceResponseAsync(id).toBlocking().single().body();
    }

    /**
     * Delete connection.
     *
     * @param id the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteConnectionAsync(String id, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteConnectionWithServiceResponseAsync(id), serviceCallback);
    }

    /**
     * Delete connection.
     *
     * @param id the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteConnectionAsync(String id) {
        return deleteConnectionWithServiceResponseAsync(id).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete connection.
     *
     * @param id the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteConnectionWithServiceResponseAsync(String id) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        return service.deleteConnection(id)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteConnectionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteConnectionDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Get connection versions.
     *
     * @param id the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;Connection&gt; object if successful.
     */
    public List<Connection> getConnectionVersions(String id) {
        return getConnectionVersionsWithServiceResponseAsync(id).toBlocking().single().body();
    }

    /**
     * Get connection versions.
     *
     * @param id the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<Connection>> getConnectionVersionsAsync(String id, final ServiceCallback<List<Connection>> serviceCallback) {
        return ServiceFuture.fromResponse(getConnectionVersionsWithServiceResponseAsync(id), serviceCallback);
    }

    /**
     * Get connection versions.
     *
     * @param id the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Connection&gt; object
     */
    public Observable<List<Connection>> getConnectionVersionsAsync(String id) {
        return getConnectionVersionsWithServiceResponseAsync(id).map(new Func1<ServiceResponse<List<Connection>>, List<Connection>>() {
            @Override
            public List<Connection> call(ServiceResponse<List<Connection>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get connection versions.
     *
     * @param id the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Connection&gt; object
     */
    public Observable<ServiceResponse<List<Connection>>> getConnectionVersionsWithServiceResponseAsync(String id) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        return service.getConnectionVersions(id)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<Connection>>>>() {
                @Override
                public Observable<ServiceResponse<List<Connection>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<Connection>> clientResponse = getConnectionVersionsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<Connection>> getConnectionVersionsDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<List<Connection>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<Connection>>() { }.getType())
                .build(response);
    }

    /**
     * Get all flows.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;Flow&gt; object if successful.
     */
    public List<Flow> getAllFlows() {
        return getAllFlowsWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Get all flows.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<Flow>> getAllFlowsAsync(final ServiceCallback<List<Flow>> serviceCallback) {
        return ServiceFuture.fromResponse(getAllFlowsWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get all flows.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Flow&gt; object
     */
    public Observable<List<Flow>> getAllFlowsAsync() {
        return getAllFlowsWithServiceResponseAsync().map(new Func1<ServiceResponse<List<Flow>>, List<Flow>>() {
            @Override
            public List<Flow> call(ServiceResponse<List<Flow>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get all flows.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Flow&gt; object
     */
    public Observable<ServiceResponse<List<Flow>>> getAllFlowsWithServiceResponseAsync() {
        final String id = null;
        final String name = null;
        final String description = null;
        final String createdBy = null;
        final String updatedBy = null;
        final String deletedBy = null;
        return service.getAllFlows(id, name, description, createdBy, updatedBy, deletedBy)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<Flow>>>>() {
                @Override
                public Observable<ServiceResponse<List<Flow>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<Flow>> clientResponse = getAllFlowsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get all flows.
     *
     * @param id the String value
     * @param name the String value
     * @param description the String value
     * @param createdBy the String value
     * @param updatedBy the String value
     * @param deletedBy the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;Flow&gt; object if successful.
     */
    public List<Flow> getAllFlows(String id, String name, String description, String createdBy, String updatedBy, String deletedBy) {
        return getAllFlowsWithServiceResponseAsync(id, name, description, createdBy, updatedBy, deletedBy).toBlocking().single().body();
    }

    /**
     * Get all flows.
     *
     * @param id the String value
     * @param name the String value
     * @param description the String value
     * @param createdBy the String value
     * @param updatedBy the String value
     * @param deletedBy the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<Flow>> getAllFlowsAsync(String id, String name, String description, String createdBy, String updatedBy, String deletedBy, final ServiceCallback<List<Flow>> serviceCallback) {
        return ServiceFuture.fromResponse(getAllFlowsWithServiceResponseAsync(id, name, description, createdBy, updatedBy, deletedBy), serviceCallback);
    }

    /**
     * Get all flows.
     *
     * @param id the String value
     * @param name the String value
     * @param description the String value
     * @param createdBy the String value
     * @param updatedBy the String value
     * @param deletedBy the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Flow&gt; object
     */
    public Observable<List<Flow>> getAllFlowsAsync(String id, String name, String description, String createdBy, String updatedBy, String deletedBy) {
        return getAllFlowsWithServiceResponseAsync(id, name, description, createdBy, updatedBy, deletedBy).map(new Func1<ServiceResponse<List<Flow>>, List<Flow>>() {
            @Override
            public List<Flow> call(ServiceResponse<List<Flow>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get all flows.
     *
     * @param id the String value
     * @param name the String value
     * @param description the String value
     * @param createdBy the String value
     * @param updatedBy the String value
     * @param deletedBy the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Flow&gt; object
     */
    public Observable<ServiceResponse<List<Flow>>> getAllFlowsWithServiceResponseAsync(String id, String name, String description, String createdBy, String updatedBy, String deletedBy) {
        return service.getAllFlows(id, name, description, createdBy, updatedBy, deletedBy)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<Flow>>>>() {
                @Override
                public Observable<ServiceResponse<List<Flow>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<Flow>> clientResponse = getAllFlowsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<Flow>> getAllFlowsDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<List<Flow>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<Flow>>() { }.getType())
                .build(response);
    }

    /**
     * Create flow.
     *
     * @param input the Flow value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object createFlow(Flow input) {
        return createFlowWithServiceResponseAsync(input).toBlocking().single().body();
    }

    /**
     * Create flow.
     *
     * @param input the Flow value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> createFlowAsync(Flow input, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(createFlowWithServiceResponseAsync(input), serviceCallback);
    }

    /**
     * Create flow.
     *
     * @param input the Flow value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> createFlowAsync(Flow input) {
        return createFlowWithServiceResponseAsync(input).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Create flow.
     *
     * @param input the Flow value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> createFlowWithServiceResponseAsync(Flow input) {
        if (input == null) {
            throw new IllegalArgumentException("Parameter input is required and cannot be null.");
        }
        Validator.validate(input);
        return service.createFlow(input)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = createFlowDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> createFlowDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(201, new TypeToken<Flow>() { }.getType())
                .register(400, new TypeToken<Map<String, List<String>>>() { }.getType())
                .build(response);
    }

    /**
     * Get one flow.
     *
     * @param id the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Flow object if successful.
     */
    public Flow getOneFlow(String id) {
        return getOneFlowWithServiceResponseAsync(id).toBlocking().single().body();
    }

    /**
     * Get one flow.
     *
     * @param id the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Flow> getOneFlowAsync(String id, final ServiceCallback<Flow> serviceCallback) {
        return ServiceFuture.fromResponse(getOneFlowWithServiceResponseAsync(id), serviceCallback);
    }

    /**
     * Get one flow.
     *
     * @param id the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Flow object
     */
    public Observable<Flow> getOneFlowAsync(String id) {
        return getOneFlowWithServiceResponseAsync(id).map(new Func1<ServiceResponse<Flow>, Flow>() {
            @Override
            public Flow call(ServiceResponse<Flow> response) {
                return response.body();
            }
        });
    }

    /**
     * Get one flow.
     *
     * @param id the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Flow object
     */
    public Observable<ServiceResponse<Flow>> getOneFlowWithServiceResponseAsync(String id) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        final Integer version = null;
        return service.getOneFlow(id, version)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Flow>>>() {
                @Override
                public Observable<ServiceResponse<Flow>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Flow> clientResponse = getOneFlowDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get one flow.
     *
     * @param id the String value
     * @param version the Integer value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Flow object if successful.
     */
    public Flow getOneFlow(String id, Integer version) {
        return getOneFlowWithServiceResponseAsync(id, version).toBlocking().single().body();
    }

    /**
     * Get one flow.
     *
     * @param id the String value
     * @param version the Integer value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Flow> getOneFlowAsync(String id, Integer version, final ServiceCallback<Flow> serviceCallback) {
        return ServiceFuture.fromResponse(getOneFlowWithServiceResponseAsync(id, version), serviceCallback);
    }

    /**
     * Get one flow.
     *
     * @param id the String value
     * @param version the Integer value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Flow object
     */
    public Observable<Flow> getOneFlowAsync(String id, Integer version) {
        return getOneFlowWithServiceResponseAsync(id, version).map(new Func1<ServiceResponse<Flow>, Flow>() {
            @Override
            public Flow call(ServiceResponse<Flow> response) {
                return response.body();
            }
        });
    }

    /**
     * Get one flow.
     *
     * @param id the String value
     * @param version the Integer value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Flow object
     */
    public Observable<ServiceResponse<Flow>> getOneFlowWithServiceResponseAsync(String id, Integer version) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        return service.getOneFlow(id, version)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Flow>>>() {
                @Override
                public Observable<ServiceResponse<Flow>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Flow> clientResponse = getOneFlowDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Flow> getOneFlowDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Flow, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Flow>() { }.getType())
                .build(response);
    }

    /**
     * Update flow.
     *
     * @param id the String value
     * @param model the Flow value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object updateFlow(String id, Flow model) {
        return updateFlowWithServiceResponseAsync(id, model).toBlocking().single().body();
    }

    /**
     * Update flow.
     *
     * @param id the String value
     * @param model the Flow value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> updateFlowAsync(String id, Flow model, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(updateFlowWithServiceResponseAsync(id, model), serviceCallback);
    }

    /**
     * Update flow.
     *
     * @param id the String value
     * @param model the Flow value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> updateFlowAsync(String id, Flow model) {
        return updateFlowWithServiceResponseAsync(id, model).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Update flow.
     *
     * @param id the String value
     * @param model the Flow value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> updateFlowWithServiceResponseAsync(String id, Flow model) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (model == null) {
            throw new IllegalArgumentException("Parameter model is required and cannot be null.");
        }
        Validator.validate(model);
        return service.updateFlow(id, model)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = updateFlowDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> updateFlowDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(202, new TypeToken<Flow>() { }.getType())
                .register(400, new TypeToken<Map<String, List<String>>>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .register(409, new TypeToken<Flow>() { }.getType())
                .build(response);
    }

    /**
     * Delete flow.
     *
     * @param id the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteFlow(String id) {
        deleteFlowWithServiceResponseAsync(id).toBlocking().single().body();
    }

    /**
     * Delete flow.
     *
     * @param id the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteFlowAsync(String id, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteFlowWithServiceResponseAsync(id), serviceCallback);
    }

    /**
     * Delete flow.
     *
     * @param id the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteFlowAsync(String id) {
        return deleteFlowWithServiceResponseAsync(id).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete flow.
     *
     * @param id the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteFlowWithServiceResponseAsync(String id) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        return service.deleteFlow(id)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteFlowDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteFlowDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Get flow versions.
     *
     * @param id the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;Flow&gt; object if successful.
     */
    public List<Flow> getFlowVersions(String id) {
        return getFlowVersionsWithServiceResponseAsync(id).toBlocking().single().body();
    }

    /**
     * Get flow versions.
     *
     * @param id the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<Flow>> getFlowVersionsAsync(String id, final ServiceCallback<List<Flow>> serviceCallback) {
        return ServiceFuture.fromResponse(getFlowVersionsWithServiceResponseAsync(id), serviceCallback);
    }

    /**
     * Get flow versions.
     *
     * @param id the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Flow&gt; object
     */
    public Observable<List<Flow>> getFlowVersionsAsync(String id) {
        return getFlowVersionsWithServiceResponseAsync(id).map(new Func1<ServiceResponse<List<Flow>>, List<Flow>>() {
            @Override
            public List<Flow> call(ServiceResponse<List<Flow>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get flow versions.
     *
     * @param id the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Flow&gt; object
     */
    public Observable<ServiceResponse<List<Flow>>> getFlowVersionsWithServiceResponseAsync(String id) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        return service.getFlowVersions(id)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<Flow>>>>() {
                @Override
                public Observable<ServiceResponse<List<Flow>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<Flow>> clientResponse = getFlowVersionsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<Flow>> getFlowVersionsDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<List<Flow>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<Flow>>() { }.getType())
                .build(response);
    }

    /**
     * Get job mapping.
     *
     * @param id the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Mapping object if successful.
     */
    public Mapping getJobMapping(String id) {
        return getJobMappingWithServiceResponseAsync(id).toBlocking().single().body();
    }

    /**
     * Get job mapping.
     *
     * @param id the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Mapping> getJobMappingAsync(String id, final ServiceCallback<Mapping> serviceCallback) {
        return ServiceFuture.fromResponse(getJobMappingWithServiceResponseAsync(id), serviceCallback);
    }

    /**
     * Get job mapping.
     *
     * @param id the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Mapping object
     */
    public Observable<Mapping> getJobMappingAsync(String id) {
        return getJobMappingWithServiceResponseAsync(id).map(new Func1<ServiceResponse<Mapping>, Mapping>() {
            @Override
            public Mapping call(ServiceResponse<Mapping> response) {
                return response.body();
            }
        });
    }

    /**
     * Get job mapping.
     *
     * @param id the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Mapping object
     */
    public Observable<ServiceResponse<Mapping>> getJobMappingWithServiceResponseAsync(String id) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        final Integer version = null;
        return service.getJobMapping(id, version)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Mapping>>>() {
                @Override
                public Observable<ServiceResponse<Mapping>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Mapping> clientResponse = getJobMappingDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get job mapping.
     *
     * @param id the String value
     * @param version the Integer value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Mapping object if successful.
     */
    public Mapping getJobMapping(String id, Integer version) {
        return getJobMappingWithServiceResponseAsync(id, version).toBlocking().single().body();
    }

    /**
     * Get job mapping.
     *
     * @param id the String value
     * @param version the Integer value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Mapping> getJobMappingAsync(String id, Integer version, final ServiceCallback<Mapping> serviceCallback) {
        return ServiceFuture.fromResponse(getJobMappingWithServiceResponseAsync(id, version), serviceCallback);
    }

    /**
     * Get job mapping.
     *
     * @param id the String value
     * @param version the Integer value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Mapping object
     */
    public Observable<Mapping> getJobMappingAsync(String id, Integer version) {
        return getJobMappingWithServiceResponseAsync(id, version).map(new Func1<ServiceResponse<Mapping>, Mapping>() {
            @Override
            public Mapping call(ServiceResponse<Mapping> response) {
                return response.body();
            }
        });
    }

    /**
     * Get job mapping.
     *
     * @param id the String value
     * @param version the Integer value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Mapping object
     */
    public Observable<ServiceResponse<Mapping>> getJobMappingWithServiceResponseAsync(String id, Integer version) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        return service.getJobMapping(id, version)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Mapping>>>() {
                @Override
                public Observable<ServiceResponse<Mapping>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Mapping> clientResponse = getJobMappingDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Mapping> getJobMappingDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Mapping, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Mapping>() { }.getType())
                .build(response);
    }

    /**
     * Set job status for go between.
     *
     * @param id the String value
     * @param status the JobStatusGoBetweenScope value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Map&lt;String, List&lt;String&gt;&gt; object if successful.
     */
    public Map<String, List<String>> setJobStatusForGoBetween(String id, JobStatusGoBetweenScope status) {
        return setJobStatusForGoBetweenWithServiceResponseAsync(id, status).toBlocking().single().body();
    }

    /**
     * Set job status for go between.
     *
     * @param id the String value
     * @param status the JobStatusGoBetweenScope value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Map<String, List<String>>> setJobStatusForGoBetweenAsync(String id, JobStatusGoBetweenScope status, final ServiceCallback<Map<String, List<String>>> serviceCallback) {
        return ServiceFuture.fromResponse(setJobStatusForGoBetweenWithServiceResponseAsync(id, status), serviceCallback);
    }

    /**
     * Set job status for go between.
     *
     * @param id the String value
     * @param status the JobStatusGoBetweenScope value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Map&lt;String, List&lt;String&gt;&gt; object
     */
    public Observable<Map<String, List<String>>> setJobStatusForGoBetweenAsync(String id, JobStatusGoBetweenScope status) {
        return setJobStatusForGoBetweenWithServiceResponseAsync(id, status).map(new Func1<ServiceResponse<Map<String, List<String>>>, Map<String, List<String>>>() {
            @Override
            public Map<String, List<String>> call(ServiceResponse<Map<String, List<String>>> response) {
                return response.body();
            }
        });
    }

    /**
     * Set job status for go between.
     *
     * @param id the String value
     * @param status the JobStatusGoBetweenScope value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Map&lt;String, List&lt;String&gt;&gt; object
     */
    public Observable<ServiceResponse<Map<String, List<String>>>> setJobStatusForGoBetweenWithServiceResponseAsync(String id, JobStatusGoBetweenScope status) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (status == null) {
            throw new IllegalArgumentException("Parameter status is required and cannot be null.");
        }
        Validator.validate(status);
        return service.setJobStatusForGoBetween(id, status)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Map<String, List<String>>>>>() {
                @Override
                public Observable<ServiceResponse<Map<String, List<String>>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Map<String, List<String>>> clientResponse = setJobStatusForGoBetweenDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Map<String, List<String>>> setJobStatusForGoBetweenDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Map<String, List<String>>, RestException>newInstance(this.serializerAdapter())
                .register(202, new TypeToken<Void>() { }.getType())
                .register(400, new TypeToken<Map<String, List<String>>>() { }.getType())
                .build(response);
    }

    /**
     * Set real time state.
     *
     * @param id the String value
     * @param state the RealTimeStateScope value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Map&lt;String, List&lt;String&gt;&gt; object if successful.
     */
    public Map<String, List<String>> setRealTimeState(String id, RealTimeStateScope state) {
        return setRealTimeStateWithServiceResponseAsync(id, state).toBlocking().single().body();
    }

    /**
     * Set real time state.
     *
     * @param id the String value
     * @param state the RealTimeStateScope value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Map<String, List<String>>> setRealTimeStateAsync(String id, RealTimeStateScope state, final ServiceCallback<Map<String, List<String>>> serviceCallback) {
        return ServiceFuture.fromResponse(setRealTimeStateWithServiceResponseAsync(id, state), serviceCallback);
    }

    /**
     * Set real time state.
     *
     * @param id the String value
     * @param state the RealTimeStateScope value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Map&lt;String, List&lt;String&gt;&gt; object
     */
    public Observable<Map<String, List<String>>> setRealTimeStateAsync(String id, RealTimeStateScope state) {
        return setRealTimeStateWithServiceResponseAsync(id, state).map(new Func1<ServiceResponse<Map<String, List<String>>>, Map<String, List<String>>>() {
            @Override
            public Map<String, List<String>> call(ServiceResponse<Map<String, List<String>>> response) {
                return response.body();
            }
        });
    }

    /**
     * Set real time state.
     *
     * @param id the String value
     * @param state the RealTimeStateScope value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Map&lt;String, List&lt;String&gt;&gt; object
     */
    public Observable<ServiceResponse<Map<String, List<String>>>> setRealTimeStateWithServiceResponseAsync(String id, RealTimeStateScope state) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (state == null) {
            throw new IllegalArgumentException("Parameter state is required and cannot be null.");
        }
        Validator.validate(state);
        return service.setRealTimeState(id, state)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Map<String, List<String>>>>>() {
                @Override
                public Observable<ServiceResponse<Map<String, List<String>>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Map<String, List<String>>> clientResponse = setRealTimeStateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Map<String, List<String>>> setRealTimeStateDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Map<String, List<String>>, RestException>newInstance(this.serializerAdapter())
                .register(202, new TypeToken<Void>() { }.getType())
                .register(400, new TypeToken<Map<String, List<String>>>() { }.getType())
                .build(response);
    }

    /**
     * Get all jobs.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;Job&gt; object if successful.
     */
    public List<Job> getAllJobs() {
        return getAllJobsWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Get all jobs.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<Job>> getAllJobsAsync(final ServiceCallback<List<Job>> serviceCallback) {
        return ServiceFuture.fromResponse(getAllJobsWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get all jobs.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Job&gt; object
     */
    public Observable<List<Job>> getAllJobsAsync() {
        return getAllJobsWithServiceResponseAsync().map(new Func1<ServiceResponse<List<Job>>, List<Job>>() {
            @Override
            public List<Job> call(ServiceResponse<List<Job>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get all jobs.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Job&gt; object
     */
    public Observable<ServiceResponse<List<Job>>> getAllJobsWithServiceResponseAsync() {
        final String id = null;
        final String name = null;
        final String description = null;
        final String connectionId = null;
        final String schemaId = null;
        final String shapeId = null;
        final String agentId = null;
        final String type = null;
        final String createdBy = null;
        final String updatedBy = null;
        final String deletedBy = null;
        return service.getAllJobs(id, name, description, connectionId, schemaId, shapeId, agentId, type, createdBy, updatedBy, deletedBy)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<Job>>>>() {
                @Override
                public Observable<ServiceResponse<List<Job>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<Job>> clientResponse = getAllJobsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get all jobs.
     *
     * @param id the String value
     * @param name the String value
     * @param description the String value
     * @param connectionId the String value
     * @param schemaId the String value
     * @param shapeId the String value
     * @param agentId the String value
     * @param type the String value
     * @param createdBy the String value
     * @param updatedBy the String value
     * @param deletedBy the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;Job&gt; object if successful.
     */
    public List<Job> getAllJobs(String id, String name, String description, String connectionId, String schemaId, String shapeId, String agentId, String type, String createdBy, String updatedBy, String deletedBy) {
        return getAllJobsWithServiceResponseAsync(id, name, description, connectionId, schemaId, shapeId, agentId, type, createdBy, updatedBy, deletedBy).toBlocking().single().body();
    }

    /**
     * Get all jobs.
     *
     * @param id the String value
     * @param name the String value
     * @param description the String value
     * @param connectionId the String value
     * @param schemaId the String value
     * @param shapeId the String value
     * @param agentId the String value
     * @param type the String value
     * @param createdBy the String value
     * @param updatedBy the String value
     * @param deletedBy the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<Job>> getAllJobsAsync(String id, String name, String description, String connectionId, String schemaId, String shapeId, String agentId, String type, String createdBy, String updatedBy, String deletedBy, final ServiceCallback<List<Job>> serviceCallback) {
        return ServiceFuture.fromResponse(getAllJobsWithServiceResponseAsync(id, name, description, connectionId, schemaId, shapeId, agentId, type, createdBy, updatedBy, deletedBy), serviceCallback);
    }

    /**
     * Get all jobs.
     *
     * @param id the String value
     * @param name the String value
     * @param description the String value
     * @param connectionId the String value
     * @param schemaId the String value
     * @param shapeId the String value
     * @param agentId the String value
     * @param type the String value
     * @param createdBy the String value
     * @param updatedBy the String value
     * @param deletedBy the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Job&gt; object
     */
    public Observable<List<Job>> getAllJobsAsync(String id, String name, String description, String connectionId, String schemaId, String shapeId, String agentId, String type, String createdBy, String updatedBy, String deletedBy) {
        return getAllJobsWithServiceResponseAsync(id, name, description, connectionId, schemaId, shapeId, agentId, type, createdBy, updatedBy, deletedBy).map(new Func1<ServiceResponse<List<Job>>, List<Job>>() {
            @Override
            public List<Job> call(ServiceResponse<List<Job>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get all jobs.
     *
     * @param id the String value
     * @param name the String value
     * @param description the String value
     * @param connectionId the String value
     * @param schemaId the String value
     * @param shapeId the String value
     * @param agentId the String value
     * @param type the String value
     * @param createdBy the String value
     * @param updatedBy the String value
     * @param deletedBy the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Job&gt; object
     */
    public Observable<ServiceResponse<List<Job>>> getAllJobsWithServiceResponseAsync(String id, String name, String description, String connectionId, String schemaId, String shapeId, String agentId, String type, String createdBy, String updatedBy, String deletedBy) {
        return service.getAllJobs(id, name, description, connectionId, schemaId, shapeId, agentId, type, createdBy, updatedBy, deletedBy)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<Job>>>>() {
                @Override
                public Observable<ServiceResponse<List<Job>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<Job>> clientResponse = getAllJobsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<Job>> getAllJobsDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<List<Job>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<Job>>() { }.getType())
                .build(response);
    }

    /**
     * Create job.
     *
     * @param input the Job value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object createJob(Job input) {
        return createJobWithServiceResponseAsync(input).toBlocking().single().body();
    }

    /**
     * Create job.
     *
     * @param input the Job value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> createJobAsync(Job input, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(createJobWithServiceResponseAsync(input), serviceCallback);
    }

    /**
     * Create job.
     *
     * @param input the Job value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> createJobAsync(Job input) {
        return createJobWithServiceResponseAsync(input).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Create job.
     *
     * @param input the Job value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> createJobWithServiceResponseAsync(Job input) {
        if (input == null) {
            throw new IllegalArgumentException("Parameter input is required and cannot be null.");
        }
        Validator.validate(input);
        return service.createJob(input)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = createJobDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> createJobDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(201, new TypeToken<Job>() { }.getType())
                .register(400, new TypeToken<Map<String, List<String>>>() { }.getType())
                .build(response);
    }

    /**
     * Get paged statuses for job.
     *
     * @param id the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedResultOfJobStatus object if successful.
     */
    public PagedResultOfJobStatus getPagedStatusesForJob(String id) {
        return getPagedStatusesForJobWithServiceResponseAsync(id).toBlocking().single().body();
    }

    /**
     * Get paged statuses for job.
     *
     * @param id the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PagedResultOfJobStatus> getPagedStatusesForJobAsync(String id, final ServiceCallback<PagedResultOfJobStatus> serviceCallback) {
        return ServiceFuture.fromResponse(getPagedStatusesForJobWithServiceResponseAsync(id), serviceCallback);
    }

    /**
     * Get paged statuses for job.
     *
     * @param id the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedResultOfJobStatus object
     */
    public Observable<PagedResultOfJobStatus> getPagedStatusesForJobAsync(String id) {
        return getPagedStatusesForJobWithServiceResponseAsync(id).map(new Func1<ServiceResponse<PagedResultOfJobStatus>, PagedResultOfJobStatus>() {
            @Override
            public PagedResultOfJobStatus call(ServiceResponse<PagedResultOfJobStatus> response) {
                return response.body();
            }
        });
    }

    /**
     * Get paged statuses for job.
     *
     * @param id the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedResultOfJobStatus object
     */
    public Observable<ServiceResponse<PagedResultOfJobStatus>> getPagedStatusesForJobWithServiceResponseAsync(String id) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        final Integer page = null;
        final Integer pageSize = null;
        return service.getPagedStatusesForJob(id, page, pageSize)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PagedResultOfJobStatus>>>() {
                @Override
                public Observable<ServiceResponse<PagedResultOfJobStatus>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PagedResultOfJobStatus> clientResponse = getPagedStatusesForJobDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get paged statuses for job.
     *
     * @param id the String value
     * @param page the Integer value
     * @param pageSize the Integer value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedResultOfJobStatus object if successful.
     */
    public PagedResultOfJobStatus getPagedStatusesForJob(String id, Integer page, Integer pageSize) {
        return getPagedStatusesForJobWithServiceResponseAsync(id, page, pageSize).toBlocking().single().body();
    }

    /**
     * Get paged statuses for job.
     *
     * @param id the String value
     * @param page the Integer value
     * @param pageSize the Integer value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PagedResultOfJobStatus> getPagedStatusesForJobAsync(String id, Integer page, Integer pageSize, final ServiceCallback<PagedResultOfJobStatus> serviceCallback) {
        return ServiceFuture.fromResponse(getPagedStatusesForJobWithServiceResponseAsync(id, page, pageSize), serviceCallback);
    }

    /**
     * Get paged statuses for job.
     *
     * @param id the String value
     * @param page the Integer value
     * @param pageSize the Integer value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedResultOfJobStatus object
     */
    public Observable<PagedResultOfJobStatus> getPagedStatusesForJobAsync(String id, Integer page, Integer pageSize) {
        return getPagedStatusesForJobWithServiceResponseAsync(id, page, pageSize).map(new Func1<ServiceResponse<PagedResultOfJobStatus>, PagedResultOfJobStatus>() {
            @Override
            public PagedResultOfJobStatus call(ServiceResponse<PagedResultOfJobStatus> response) {
                return response.body();
            }
        });
    }

    /**
     * Get paged statuses for job.
     *
     * @param id the String value
     * @param page the Integer value
     * @param pageSize the Integer value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedResultOfJobStatus object
     */
    public Observable<ServiceResponse<PagedResultOfJobStatus>> getPagedStatusesForJobWithServiceResponseAsync(String id, Integer page, Integer pageSize) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        return service.getPagedStatusesForJob(id, page, pageSize)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PagedResultOfJobStatus>>>() {
                @Override
                public Observable<ServiceResponse<PagedResultOfJobStatus>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PagedResultOfJobStatus> clientResponse = getPagedStatusesForJobDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PagedResultOfJobStatus> getPagedStatusesForJobDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<PagedResultOfJobStatus, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<PagedResultOfJobStatus>() { }.getType())
                .build(response);
    }

    /**
     * Events placeholder for job.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the DataflowEvent object if successful.
     */
    public DataflowEvent eventsPlaceholderForJob() {
        return eventsPlaceholderForJobWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Events placeholder for job.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<DataflowEvent> eventsPlaceholderForJobAsync(final ServiceCallback<DataflowEvent> serviceCallback) {
        return ServiceFuture.fromResponse(eventsPlaceholderForJobWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Events placeholder for job.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DataflowEvent object
     */
    public Observable<DataflowEvent> eventsPlaceholderForJobAsync() {
        return eventsPlaceholderForJobWithServiceResponseAsync().map(new Func1<ServiceResponse<DataflowEvent>, DataflowEvent>() {
            @Override
            public DataflowEvent call(ServiceResponse<DataflowEvent> response) {
                return response.body();
            }
        });
    }

    /**
     * Events placeholder for job.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DataflowEvent object
     */
    public Observable<ServiceResponse<DataflowEvent>> eventsPlaceholderForJobWithServiceResponseAsync() {
        return service.eventsPlaceholderForJob()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<DataflowEvent>>>() {
                @Override
                public Observable<ServiceResponse<DataflowEvent>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<DataflowEvent> clientResponse = eventsPlaceholderForJobDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<DataflowEvent> eventsPlaceholderForJobDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<DataflowEvent, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<DataflowEvent>() { }.getType())
                .build(response);
    }

    /**
     * Get one job.
     *
     * @param id the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Job object if successful.
     */
    public Job getOneJob(String id) {
        return getOneJobWithServiceResponseAsync(id).toBlocking().single().body();
    }

    /**
     * Get one job.
     *
     * @param id the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Job> getOneJobAsync(String id, final ServiceCallback<Job> serviceCallback) {
        return ServiceFuture.fromResponse(getOneJobWithServiceResponseAsync(id), serviceCallback);
    }

    /**
     * Get one job.
     *
     * @param id the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Job object
     */
    public Observable<Job> getOneJobAsync(String id) {
        return getOneJobWithServiceResponseAsync(id).map(new Func1<ServiceResponse<Job>, Job>() {
            @Override
            public Job call(ServiceResponse<Job> response) {
                return response.body();
            }
        });
    }

    /**
     * Get one job.
     *
     * @param id the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Job object
     */
    public Observable<ServiceResponse<Job>> getOneJobWithServiceResponseAsync(String id) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        final Integer version = null;
        return service.getOneJob(id, version)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Job>>>() {
                @Override
                public Observable<ServiceResponse<Job>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Job> clientResponse = getOneJobDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get one job.
     *
     * @param id the String value
     * @param version the Integer value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Job object if successful.
     */
    public Job getOneJob(String id, Integer version) {
        return getOneJobWithServiceResponseAsync(id, version).toBlocking().single().body();
    }

    /**
     * Get one job.
     *
     * @param id the String value
     * @param version the Integer value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Job> getOneJobAsync(String id, Integer version, final ServiceCallback<Job> serviceCallback) {
        return ServiceFuture.fromResponse(getOneJobWithServiceResponseAsync(id, version), serviceCallback);
    }

    /**
     * Get one job.
     *
     * @param id the String value
     * @param version the Integer value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Job object
     */
    public Observable<Job> getOneJobAsync(String id, Integer version) {
        return getOneJobWithServiceResponseAsync(id, version).map(new Func1<ServiceResponse<Job>, Job>() {
            @Override
            public Job call(ServiceResponse<Job> response) {
                return response.body();
            }
        });
    }

    /**
     * Get one job.
     *
     * @param id the String value
     * @param version the Integer value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Job object
     */
    public Observable<ServiceResponse<Job>> getOneJobWithServiceResponseAsync(String id, Integer version) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        return service.getOneJob(id, version)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Job>>>() {
                @Override
                public Observable<ServiceResponse<Job>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Job> clientResponse = getOneJobDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Job> getOneJobDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Job, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Job>() { }.getType())
                .build(response);
    }

    /**
     * Update job.
     *
     * @param id the String value
     * @param model the Job value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object updateJob(String id, Job model) {
        return updateJobWithServiceResponseAsync(id, model).toBlocking().single().body();
    }

    /**
     * Update job.
     *
     * @param id the String value
     * @param model the Job value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> updateJobAsync(String id, Job model, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(updateJobWithServiceResponseAsync(id, model), serviceCallback);
    }

    /**
     * Update job.
     *
     * @param id the String value
     * @param model the Job value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> updateJobAsync(String id, Job model) {
        return updateJobWithServiceResponseAsync(id, model).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Update job.
     *
     * @param id the String value
     * @param model the Job value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> updateJobWithServiceResponseAsync(String id, Job model) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (model == null) {
            throw new IllegalArgumentException("Parameter model is required and cannot be null.");
        }
        Validator.validate(model);
        return service.updateJob(id, model)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = updateJobDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> updateJobDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(202, new TypeToken<Job>() { }.getType())
                .register(400, new TypeToken<Map<String, List<String>>>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .register(409, new TypeToken<Job>() { }.getType())
                .build(response);
    }

    /**
     * Delete job.
     *
     * @param id the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteJob(String id) {
        deleteJobWithServiceResponseAsync(id).toBlocking().single().body();
    }

    /**
     * Delete job.
     *
     * @param id the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteJobAsync(String id, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteJobWithServiceResponseAsync(id), serviceCallback);
    }

    /**
     * Delete job.
     *
     * @param id the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteJobAsync(String id) {
        return deleteJobWithServiceResponseAsync(id).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete job.
     *
     * @param id the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteJobWithServiceResponseAsync(String id) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        return service.deleteJob(id)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteJobDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteJobDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Get job versions.
     *
     * @param id the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;Job&gt; object if successful.
     */
    public List<Job> getJobVersions(String id) {
        return getJobVersionsWithServiceResponseAsync(id).toBlocking().single().body();
    }

    /**
     * Get job versions.
     *
     * @param id the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<Job>> getJobVersionsAsync(String id, final ServiceCallback<List<Job>> serviceCallback) {
        return ServiceFuture.fromResponse(getJobVersionsWithServiceResponseAsync(id), serviceCallback);
    }

    /**
     * Get job versions.
     *
     * @param id the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Job&gt; object
     */
    public Observable<List<Job>> getJobVersionsAsync(String id) {
        return getJobVersionsWithServiceResponseAsync(id).map(new Func1<ServiceResponse<List<Job>>, List<Job>>() {
            @Override
            public List<Job> call(ServiceResponse<List<Job>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get job versions.
     *
     * @param id the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Job&gt; object
     */
    public Observable<ServiceResponse<List<Job>>> getJobVersionsWithServiceResponseAsync(String id) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        return service.getJobVersions(id)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<Job>>>>() {
                @Override
                public Observable<ServiceResponse<List<Job>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<Job>> clientResponse = getJobVersionsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<Job>> getJobVersionsDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<List<Job>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<Job>>() { }.getType())
                .build(response);
    }

    /**
     * Get all schema profiles.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;SchemaProfile&gt; object if successful.
     */
    public List<SchemaProfile> getAllSchemaProfiles() {
        return getAllSchemaProfilesWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Get all schema profiles.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<SchemaProfile>> getAllSchemaProfilesAsync(final ServiceCallback<List<SchemaProfile>> serviceCallback) {
        return ServiceFuture.fromResponse(getAllSchemaProfilesWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get all schema profiles.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;SchemaProfile&gt; object
     */
    public Observable<List<SchemaProfile>> getAllSchemaProfilesAsync() {
        return getAllSchemaProfilesWithServiceResponseAsync().map(new Func1<ServiceResponse<List<SchemaProfile>>, List<SchemaProfile>>() {
            @Override
            public List<SchemaProfile> call(ServiceResponse<List<SchemaProfile>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get all schema profiles.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;SchemaProfile&gt; object
     */
    public Observable<ServiceResponse<List<SchemaProfile>>> getAllSchemaProfilesWithServiceResponseAsync() {
        final String id = null;
        final String name = null;
        final String description = null;
        final String connectionId = null;
        final String createdBy = null;
        final String updatedBy = null;
        final String deletedBy = null;
        return service.getAllSchemaProfiles(id, name, description, connectionId, createdBy, updatedBy, deletedBy)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<SchemaProfile>>>>() {
                @Override
                public Observable<ServiceResponse<List<SchemaProfile>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<SchemaProfile>> clientResponse = getAllSchemaProfilesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get all schema profiles.
     *
     * @param id the String value
     * @param name the String value
     * @param description the String value
     * @param connectionId the String value
     * @param createdBy the String value
     * @param updatedBy the String value
     * @param deletedBy the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;SchemaProfile&gt; object if successful.
     */
    public List<SchemaProfile> getAllSchemaProfiles(String id, String name, String description, String connectionId, String createdBy, String updatedBy, String deletedBy) {
        return getAllSchemaProfilesWithServiceResponseAsync(id, name, description, connectionId, createdBy, updatedBy, deletedBy).toBlocking().single().body();
    }

    /**
     * Get all schema profiles.
     *
     * @param id the String value
     * @param name the String value
     * @param description the String value
     * @param connectionId the String value
     * @param createdBy the String value
     * @param updatedBy the String value
     * @param deletedBy the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<SchemaProfile>> getAllSchemaProfilesAsync(String id, String name, String description, String connectionId, String createdBy, String updatedBy, String deletedBy, final ServiceCallback<List<SchemaProfile>> serviceCallback) {
        return ServiceFuture.fromResponse(getAllSchemaProfilesWithServiceResponseAsync(id, name, description, connectionId, createdBy, updatedBy, deletedBy), serviceCallback);
    }

    /**
     * Get all schema profiles.
     *
     * @param id the String value
     * @param name the String value
     * @param description the String value
     * @param connectionId the String value
     * @param createdBy the String value
     * @param updatedBy the String value
     * @param deletedBy the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;SchemaProfile&gt; object
     */
    public Observable<List<SchemaProfile>> getAllSchemaProfilesAsync(String id, String name, String description, String connectionId, String createdBy, String updatedBy, String deletedBy) {
        return getAllSchemaProfilesWithServiceResponseAsync(id, name, description, connectionId, createdBy, updatedBy, deletedBy).map(new Func1<ServiceResponse<List<SchemaProfile>>, List<SchemaProfile>>() {
            @Override
            public List<SchemaProfile> call(ServiceResponse<List<SchemaProfile>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get all schema profiles.
     *
     * @param id the String value
     * @param name the String value
     * @param description the String value
     * @param connectionId the String value
     * @param createdBy the String value
     * @param updatedBy the String value
     * @param deletedBy the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;SchemaProfile&gt; object
     */
    public Observable<ServiceResponse<List<SchemaProfile>>> getAllSchemaProfilesWithServiceResponseAsync(String id, String name, String description, String connectionId, String createdBy, String updatedBy, String deletedBy) {
        return service.getAllSchemaProfiles(id, name, description, connectionId, createdBy, updatedBy, deletedBy)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<SchemaProfile>>>>() {
                @Override
                public Observable<ServiceResponse<List<SchemaProfile>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<SchemaProfile>> clientResponse = getAllSchemaProfilesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<SchemaProfile>> getAllSchemaProfilesDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<List<SchemaProfile>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<SchemaProfile>>() { }.getType())
                .build(response);
    }

    /**
     * Create schema profile.
     *
     * @param input the SchemaProfile value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object createSchemaProfile(SchemaProfile input) {
        return createSchemaProfileWithServiceResponseAsync(input).toBlocking().single().body();
    }

    /**
     * Create schema profile.
     *
     * @param input the SchemaProfile value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> createSchemaProfileAsync(SchemaProfile input, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(createSchemaProfileWithServiceResponseAsync(input), serviceCallback);
    }

    /**
     * Create schema profile.
     *
     * @param input the SchemaProfile value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> createSchemaProfileAsync(SchemaProfile input) {
        return createSchemaProfileWithServiceResponseAsync(input).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Create schema profile.
     *
     * @param input the SchemaProfile value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> createSchemaProfileWithServiceResponseAsync(SchemaProfile input) {
        if (input == null) {
            throw new IllegalArgumentException("Parameter input is required and cannot be null.");
        }
        Validator.validate(input);
        return service.createSchemaProfile(input)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = createSchemaProfileDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> createSchemaProfileDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(201, new TypeToken<SchemaProfile>() { }.getType())
                .register(400, new TypeToken<Map<String, List<String>>>() { }.getType())
                .build(response);
    }

    /**
     * Get one schema profile.
     *
     * @param id the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SchemaProfile object if successful.
     */
    public SchemaProfile getOneSchemaProfile(String id) {
        return getOneSchemaProfileWithServiceResponseAsync(id).toBlocking().single().body();
    }

    /**
     * Get one schema profile.
     *
     * @param id the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SchemaProfile> getOneSchemaProfileAsync(String id, final ServiceCallback<SchemaProfile> serviceCallback) {
        return ServiceFuture.fromResponse(getOneSchemaProfileWithServiceResponseAsync(id), serviceCallback);
    }

    /**
     * Get one schema profile.
     *
     * @param id the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SchemaProfile object
     */
    public Observable<SchemaProfile> getOneSchemaProfileAsync(String id) {
        return getOneSchemaProfileWithServiceResponseAsync(id).map(new Func1<ServiceResponse<SchemaProfile>, SchemaProfile>() {
            @Override
            public SchemaProfile call(ServiceResponse<SchemaProfile> response) {
                return response.body();
            }
        });
    }

    /**
     * Get one schema profile.
     *
     * @param id the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SchemaProfile object
     */
    public Observable<ServiceResponse<SchemaProfile>> getOneSchemaProfileWithServiceResponseAsync(String id) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        final Integer version = null;
        return service.getOneSchemaProfile(id, version)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SchemaProfile>>>() {
                @Override
                public Observable<ServiceResponse<SchemaProfile>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SchemaProfile> clientResponse = getOneSchemaProfileDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get one schema profile.
     *
     * @param id the String value
     * @param version the Integer value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SchemaProfile object if successful.
     */
    public SchemaProfile getOneSchemaProfile(String id, Integer version) {
        return getOneSchemaProfileWithServiceResponseAsync(id, version).toBlocking().single().body();
    }

    /**
     * Get one schema profile.
     *
     * @param id the String value
     * @param version the Integer value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SchemaProfile> getOneSchemaProfileAsync(String id, Integer version, final ServiceCallback<SchemaProfile> serviceCallback) {
        return ServiceFuture.fromResponse(getOneSchemaProfileWithServiceResponseAsync(id, version), serviceCallback);
    }

    /**
     * Get one schema profile.
     *
     * @param id the String value
     * @param version the Integer value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SchemaProfile object
     */
    public Observable<SchemaProfile> getOneSchemaProfileAsync(String id, Integer version) {
        return getOneSchemaProfileWithServiceResponseAsync(id, version).map(new Func1<ServiceResponse<SchemaProfile>, SchemaProfile>() {
            @Override
            public SchemaProfile call(ServiceResponse<SchemaProfile> response) {
                return response.body();
            }
        });
    }

    /**
     * Get one schema profile.
     *
     * @param id the String value
     * @param version the Integer value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SchemaProfile object
     */
    public Observable<ServiceResponse<SchemaProfile>> getOneSchemaProfileWithServiceResponseAsync(String id, Integer version) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        return service.getOneSchemaProfile(id, version)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SchemaProfile>>>() {
                @Override
                public Observable<ServiceResponse<SchemaProfile>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SchemaProfile> clientResponse = getOneSchemaProfileDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SchemaProfile> getOneSchemaProfileDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<SchemaProfile, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<SchemaProfile>() { }.getType())
                .build(response);
    }

    /**
     * Update schema profile.
     *
     * @param id the String value
     * @param model the SchemaProfile value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object updateSchemaProfile(String id, SchemaProfile model) {
        return updateSchemaProfileWithServiceResponseAsync(id, model).toBlocking().single().body();
    }

    /**
     * Update schema profile.
     *
     * @param id the String value
     * @param model the SchemaProfile value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> updateSchemaProfileAsync(String id, SchemaProfile model, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(updateSchemaProfileWithServiceResponseAsync(id, model), serviceCallback);
    }

    /**
     * Update schema profile.
     *
     * @param id the String value
     * @param model the SchemaProfile value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> updateSchemaProfileAsync(String id, SchemaProfile model) {
        return updateSchemaProfileWithServiceResponseAsync(id, model).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Update schema profile.
     *
     * @param id the String value
     * @param model the SchemaProfile value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> updateSchemaProfileWithServiceResponseAsync(String id, SchemaProfile model) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (model == null) {
            throw new IllegalArgumentException("Parameter model is required and cannot be null.");
        }
        Validator.validate(model);
        return service.updateSchemaProfile(id, model)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = updateSchemaProfileDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> updateSchemaProfileDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(202, new TypeToken<SchemaProfile>() { }.getType())
                .register(400, new TypeToken<Map<String, List<String>>>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .register(409, new TypeToken<SchemaProfile>() { }.getType())
                .build(response);
    }

    /**
     * Delete schema profile.
     *
     * @param id the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteSchemaProfile(String id) {
        deleteSchemaProfileWithServiceResponseAsync(id).toBlocking().single().body();
    }

    /**
     * Delete schema profile.
     *
     * @param id the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteSchemaProfileAsync(String id, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteSchemaProfileWithServiceResponseAsync(id), serviceCallback);
    }

    /**
     * Delete schema profile.
     *
     * @param id the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteSchemaProfileAsync(String id) {
        return deleteSchemaProfileWithServiceResponseAsync(id).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete schema profile.
     *
     * @param id the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteSchemaProfileWithServiceResponseAsync(String id) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        return service.deleteSchemaProfile(id)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteSchemaProfileDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteSchemaProfileDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Get schema profile versions.
     *
     * @param id the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;SchemaProfile&gt; object if successful.
     */
    public List<SchemaProfile> getSchemaProfileVersions(String id) {
        return getSchemaProfileVersionsWithServiceResponseAsync(id).toBlocking().single().body();
    }

    /**
     * Get schema profile versions.
     *
     * @param id the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<SchemaProfile>> getSchemaProfileVersionsAsync(String id, final ServiceCallback<List<SchemaProfile>> serviceCallback) {
        return ServiceFuture.fromResponse(getSchemaProfileVersionsWithServiceResponseAsync(id), serviceCallback);
    }

    /**
     * Get schema profile versions.
     *
     * @param id the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;SchemaProfile&gt; object
     */
    public Observable<List<SchemaProfile>> getSchemaProfileVersionsAsync(String id) {
        return getSchemaProfileVersionsWithServiceResponseAsync(id).map(new Func1<ServiceResponse<List<SchemaProfile>>, List<SchemaProfile>>() {
            @Override
            public List<SchemaProfile> call(ServiceResponse<List<SchemaProfile>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get schema profile versions.
     *
     * @param id the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;SchemaProfile&gt; object
     */
    public Observable<ServiceResponse<List<SchemaProfile>>> getSchemaProfileVersionsWithServiceResponseAsync(String id) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        return service.getSchemaProfileVersions(id)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<SchemaProfile>>>>() {
                @Override
                public Observable<ServiceResponse<List<SchemaProfile>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<SchemaProfile>> clientResponse = getSchemaProfileVersionsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<SchemaProfile>> getSchemaProfileVersionsDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<List<SchemaProfile>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<SchemaProfile>>() { }.getType())
                .build(response);
    }

    /**
     * Get all schemas.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;Schema&gt; object if successful.
     */
    public List<Schema> getAllSchemas() {
        return getAllSchemasWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Get all schemas.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<Schema>> getAllSchemasAsync(final ServiceCallback<List<Schema>> serviceCallback) {
        return ServiceFuture.fromResponse(getAllSchemasWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get all schemas.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Schema&gt; object
     */
    public Observable<List<Schema>> getAllSchemasAsync() {
        return getAllSchemasWithServiceResponseAsync().map(new Func1<ServiceResponse<List<Schema>>, List<Schema>>() {
            @Override
            public List<Schema> call(ServiceResponse<List<Schema>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get all schemas.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Schema&gt; object
     */
    public Observable<ServiceResponse<List<Schema>>> getAllSchemasWithServiceResponseAsync() {
        final String id = null;
        final String name = null;
        final String description = null;
        final String discoveredId = null;
        final String discoveredName = null;
        final String discoveredDescription = null;
        final String query = null;
        final String connectionId = null;
        final String profilingJobId = null;
        final String publisherMetaJson = null;
        final String capability = null;
        final String createdBy = null;
        final String updatedBy = null;
        final String deletedBy = null;
        return service.getAllSchemas(id, name, description, discoveredId, discoveredName, discoveredDescription, query, connectionId, profilingJobId, publisherMetaJson, capability, createdBy, updatedBy, deletedBy)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<Schema>>>>() {
                @Override
                public Observable<ServiceResponse<List<Schema>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<Schema>> clientResponse = getAllSchemasDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get all schemas.
     *
     * @param id the String value
     * @param name the String value
     * @param description the String value
     * @param discoveredId the String value
     * @param discoveredName the String value
     * @param discoveredDescription the String value
     * @param query the String value
     * @param connectionId the String value
     * @param profilingJobId the String value
     * @param publisherMetaJson the String value
     * @param capability the String value
     * @param createdBy the String value
     * @param updatedBy the String value
     * @param deletedBy the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;Schema&gt; object if successful.
     */
    public List<Schema> getAllSchemas(String id, String name, String description, String discoveredId, String discoveredName, String discoveredDescription, String query, String connectionId, String profilingJobId, String publisherMetaJson, String capability, String createdBy, String updatedBy, String deletedBy) {
        return getAllSchemasWithServiceResponseAsync(id, name, description, discoveredId, discoveredName, discoveredDescription, query, connectionId, profilingJobId, publisherMetaJson, capability, createdBy, updatedBy, deletedBy).toBlocking().single().body();
    }

    /**
     * Get all schemas.
     *
     * @param id the String value
     * @param name the String value
     * @param description the String value
     * @param discoveredId the String value
     * @param discoveredName the String value
     * @param discoveredDescription the String value
     * @param query the String value
     * @param connectionId the String value
     * @param profilingJobId the String value
     * @param publisherMetaJson the String value
     * @param capability the String value
     * @param createdBy the String value
     * @param updatedBy the String value
     * @param deletedBy the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<Schema>> getAllSchemasAsync(String id, String name, String description, String discoveredId, String discoveredName, String discoveredDescription, String query, String connectionId, String profilingJobId, String publisherMetaJson, String capability, String createdBy, String updatedBy, String deletedBy, final ServiceCallback<List<Schema>> serviceCallback) {
        return ServiceFuture.fromResponse(getAllSchemasWithServiceResponseAsync(id, name, description, discoveredId, discoveredName, discoveredDescription, query, connectionId, profilingJobId, publisherMetaJson, capability, createdBy, updatedBy, deletedBy), serviceCallback);
    }

    /**
     * Get all schemas.
     *
     * @param id the String value
     * @param name the String value
     * @param description the String value
     * @param discoveredId the String value
     * @param discoveredName the String value
     * @param discoveredDescription the String value
     * @param query the String value
     * @param connectionId the String value
     * @param profilingJobId the String value
     * @param publisherMetaJson the String value
     * @param capability the String value
     * @param createdBy the String value
     * @param updatedBy the String value
     * @param deletedBy the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Schema&gt; object
     */
    public Observable<List<Schema>> getAllSchemasAsync(String id, String name, String description, String discoveredId, String discoveredName, String discoveredDescription, String query, String connectionId, String profilingJobId, String publisherMetaJson, String capability, String createdBy, String updatedBy, String deletedBy) {
        return getAllSchemasWithServiceResponseAsync(id, name, description, discoveredId, discoveredName, discoveredDescription, query, connectionId, profilingJobId, publisherMetaJson, capability, createdBy, updatedBy, deletedBy).map(new Func1<ServiceResponse<List<Schema>>, List<Schema>>() {
            @Override
            public List<Schema> call(ServiceResponse<List<Schema>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get all schemas.
     *
     * @param id the String value
     * @param name the String value
     * @param description the String value
     * @param discoveredId the String value
     * @param discoveredName the String value
     * @param discoveredDescription the String value
     * @param query the String value
     * @param connectionId the String value
     * @param profilingJobId the String value
     * @param publisherMetaJson the String value
     * @param capability the String value
     * @param createdBy the String value
     * @param updatedBy the String value
     * @param deletedBy the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Schema&gt; object
     */
    public Observable<ServiceResponse<List<Schema>>> getAllSchemasWithServiceResponseAsync(String id, String name, String description, String discoveredId, String discoveredName, String discoveredDescription, String query, String connectionId, String profilingJobId, String publisherMetaJson, String capability, String createdBy, String updatedBy, String deletedBy) {
        return service.getAllSchemas(id, name, description, discoveredId, discoveredName, discoveredDescription, query, connectionId, profilingJobId, publisherMetaJson, capability, createdBy, updatedBy, deletedBy)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<Schema>>>>() {
                @Override
                public Observable<ServiceResponse<List<Schema>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<Schema>> clientResponse = getAllSchemasDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<Schema>> getAllSchemasDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<List<Schema>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<Schema>>() { }.getType())
                .build(response);
    }

    /**
     * Create schema.
     *
     * @param input the Schema value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object createSchema(Schema input) {
        return createSchemaWithServiceResponseAsync(input).toBlocking().single().body();
    }

    /**
     * Create schema.
     *
     * @param input the Schema value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> createSchemaAsync(Schema input, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(createSchemaWithServiceResponseAsync(input), serviceCallback);
    }

    /**
     * Create schema.
     *
     * @param input the Schema value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> createSchemaAsync(Schema input) {
        return createSchemaWithServiceResponseAsync(input).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Create schema.
     *
     * @param input the Schema value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> createSchemaWithServiceResponseAsync(Schema input) {
        if (input == null) {
            throw new IllegalArgumentException("Parameter input is required and cannot be null.");
        }
        Validator.validate(input);
        return service.createSchema(input)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = createSchemaDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> createSchemaDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(201, new TypeToken<Schema>() { }.getType())
                .register(400, new TypeToken<Map<String, List<String>>>() { }.getType())
                .build(response);
    }

    /**
     * Get one schema.
     *
     * @param id the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Schema object if successful.
     */
    public Schema getOneSchema(String id) {
        return getOneSchemaWithServiceResponseAsync(id).toBlocking().single().body();
    }

    /**
     * Get one schema.
     *
     * @param id the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Schema> getOneSchemaAsync(String id, final ServiceCallback<Schema> serviceCallback) {
        return ServiceFuture.fromResponse(getOneSchemaWithServiceResponseAsync(id), serviceCallback);
    }

    /**
     * Get one schema.
     *
     * @param id the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Schema object
     */
    public Observable<Schema> getOneSchemaAsync(String id) {
        return getOneSchemaWithServiceResponseAsync(id).map(new Func1<ServiceResponse<Schema>, Schema>() {
            @Override
            public Schema call(ServiceResponse<Schema> response) {
                return response.body();
            }
        });
    }

    /**
     * Get one schema.
     *
     * @param id the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Schema object
     */
    public Observable<ServiceResponse<Schema>> getOneSchemaWithServiceResponseAsync(String id) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        final Integer version = null;
        return service.getOneSchema(id, version)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Schema>>>() {
                @Override
                public Observable<ServiceResponse<Schema>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Schema> clientResponse = getOneSchemaDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get one schema.
     *
     * @param id the String value
     * @param version the Integer value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Schema object if successful.
     */
    public Schema getOneSchema(String id, Integer version) {
        return getOneSchemaWithServiceResponseAsync(id, version).toBlocking().single().body();
    }

    /**
     * Get one schema.
     *
     * @param id the String value
     * @param version the Integer value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Schema> getOneSchemaAsync(String id, Integer version, final ServiceCallback<Schema> serviceCallback) {
        return ServiceFuture.fromResponse(getOneSchemaWithServiceResponseAsync(id, version), serviceCallback);
    }

    /**
     * Get one schema.
     *
     * @param id the String value
     * @param version the Integer value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Schema object
     */
    public Observable<Schema> getOneSchemaAsync(String id, Integer version) {
        return getOneSchemaWithServiceResponseAsync(id, version).map(new Func1<ServiceResponse<Schema>, Schema>() {
            @Override
            public Schema call(ServiceResponse<Schema> response) {
                return response.body();
            }
        });
    }

    /**
     * Get one schema.
     *
     * @param id the String value
     * @param version the Integer value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Schema object
     */
    public Observable<ServiceResponse<Schema>> getOneSchemaWithServiceResponseAsync(String id, Integer version) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        return service.getOneSchema(id, version)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Schema>>>() {
                @Override
                public Observable<ServiceResponse<Schema>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Schema> clientResponse = getOneSchemaDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Schema> getOneSchemaDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Schema, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Schema>() { }.getType())
                .build(response);
    }

    /**
     * Update schema.
     *
     * @param id the String value
     * @param model the Schema value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object updateSchema(String id, Schema model) {
        return updateSchemaWithServiceResponseAsync(id, model).toBlocking().single().body();
    }

    /**
     * Update schema.
     *
     * @param id the String value
     * @param model the Schema value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> updateSchemaAsync(String id, Schema model, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(updateSchemaWithServiceResponseAsync(id, model), serviceCallback);
    }

    /**
     * Update schema.
     *
     * @param id the String value
     * @param model the Schema value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> updateSchemaAsync(String id, Schema model) {
        return updateSchemaWithServiceResponseAsync(id, model).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Update schema.
     *
     * @param id the String value
     * @param model the Schema value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> updateSchemaWithServiceResponseAsync(String id, Schema model) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (model == null) {
            throw new IllegalArgumentException("Parameter model is required and cannot be null.");
        }
        Validator.validate(model);
        return service.updateSchema(id, model)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = updateSchemaDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> updateSchemaDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(202, new TypeToken<Schema>() { }.getType())
                .register(400, new TypeToken<Map<String, List<String>>>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .register(409, new TypeToken<Schema>() { }.getType())
                .build(response);
    }

    /**
     * Delete schema.
     *
     * @param id the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteSchema(String id) {
        deleteSchemaWithServiceResponseAsync(id).toBlocking().single().body();
    }

    /**
     * Delete schema.
     *
     * @param id the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteSchemaAsync(String id, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteSchemaWithServiceResponseAsync(id), serviceCallback);
    }

    /**
     * Delete schema.
     *
     * @param id the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteSchemaAsync(String id) {
        return deleteSchemaWithServiceResponseAsync(id).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete schema.
     *
     * @param id the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteSchemaWithServiceResponseAsync(String id) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        return service.deleteSchema(id)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteSchemaDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteSchemaDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Get schema versions.
     *
     * @param id the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;Schema&gt; object if successful.
     */
    public List<Schema> getSchemaVersions(String id) {
        return getSchemaVersionsWithServiceResponseAsync(id).toBlocking().single().body();
    }

    /**
     * Get schema versions.
     *
     * @param id the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<Schema>> getSchemaVersionsAsync(String id, final ServiceCallback<List<Schema>> serviceCallback) {
        return ServiceFuture.fromResponse(getSchemaVersionsWithServiceResponseAsync(id), serviceCallback);
    }

    /**
     * Get schema versions.
     *
     * @param id the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Schema&gt; object
     */
    public Observable<List<Schema>> getSchemaVersionsAsync(String id) {
        return getSchemaVersionsWithServiceResponseAsync(id).map(new Func1<ServiceResponse<List<Schema>>, List<Schema>>() {
            @Override
            public List<Schema> call(ServiceResponse<List<Schema>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get schema versions.
     *
     * @param id the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Schema&gt; object
     */
    public Observable<ServiceResponse<List<Schema>>> getSchemaVersionsWithServiceResponseAsync(String id) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        return service.getSchemaVersions(id)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<Schema>>>>() {
                @Override
                public Observable<ServiceResponse<List<Schema>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<Schema>> clientResponse = getSchemaVersionsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<Schema>> getSchemaVersionsDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<List<Schema>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<Schema>>() { }.getType())
                .build(response);
    }

    /**
     * Get all shapes.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;Shape&gt; object if successful.
     */
    public List<Shape> getAllShapes() {
        return getAllShapesWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Get all shapes.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<Shape>> getAllShapesAsync(final ServiceCallback<List<Shape>> serviceCallback) {
        return ServiceFuture.fromResponse(getAllShapesWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get all shapes.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Shape&gt; object
     */
    public Observable<List<Shape>> getAllShapesAsync() {
        return getAllShapesWithServiceResponseAsync().map(new Func1<ServiceResponse<List<Shape>>, List<Shape>>() {
            @Override
            public List<Shape> call(ServiceResponse<List<Shape>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get all shapes.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Shape&gt; object
     */
    public Observable<ServiceResponse<List<Shape>>> getAllShapesWithServiceResponseAsync() {
        final String id = null;
        final String name = null;
        final String description = null;
        final String copiedFromSchemaId = null;
        final String createdBy = null;
        final String updatedBy = null;
        final String deletedBy = null;
        return service.getAllShapes(id, name, description, copiedFromSchemaId, createdBy, updatedBy, deletedBy)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<Shape>>>>() {
                @Override
                public Observable<ServiceResponse<List<Shape>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<Shape>> clientResponse = getAllShapesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get all shapes.
     *
     * @param id the String value
     * @param name the String value
     * @param description the String value
     * @param copiedFromSchemaId the String value
     * @param createdBy the String value
     * @param updatedBy the String value
     * @param deletedBy the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;Shape&gt; object if successful.
     */
    public List<Shape> getAllShapes(String id, String name, String description, String copiedFromSchemaId, String createdBy, String updatedBy, String deletedBy) {
        return getAllShapesWithServiceResponseAsync(id, name, description, copiedFromSchemaId, createdBy, updatedBy, deletedBy).toBlocking().single().body();
    }

    /**
     * Get all shapes.
     *
     * @param id the String value
     * @param name the String value
     * @param description the String value
     * @param copiedFromSchemaId the String value
     * @param createdBy the String value
     * @param updatedBy the String value
     * @param deletedBy the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<Shape>> getAllShapesAsync(String id, String name, String description, String copiedFromSchemaId, String createdBy, String updatedBy, String deletedBy, final ServiceCallback<List<Shape>> serviceCallback) {
        return ServiceFuture.fromResponse(getAllShapesWithServiceResponseAsync(id, name, description, copiedFromSchemaId, createdBy, updatedBy, deletedBy), serviceCallback);
    }

    /**
     * Get all shapes.
     *
     * @param id the String value
     * @param name the String value
     * @param description the String value
     * @param copiedFromSchemaId the String value
     * @param createdBy the String value
     * @param updatedBy the String value
     * @param deletedBy the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Shape&gt; object
     */
    public Observable<List<Shape>> getAllShapesAsync(String id, String name, String description, String copiedFromSchemaId, String createdBy, String updatedBy, String deletedBy) {
        return getAllShapesWithServiceResponseAsync(id, name, description, copiedFromSchemaId, createdBy, updatedBy, deletedBy).map(new Func1<ServiceResponse<List<Shape>>, List<Shape>>() {
            @Override
            public List<Shape> call(ServiceResponse<List<Shape>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get all shapes.
     *
     * @param id the String value
     * @param name the String value
     * @param description the String value
     * @param copiedFromSchemaId the String value
     * @param createdBy the String value
     * @param updatedBy the String value
     * @param deletedBy the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Shape&gt; object
     */
    public Observable<ServiceResponse<List<Shape>>> getAllShapesWithServiceResponseAsync(String id, String name, String description, String copiedFromSchemaId, String createdBy, String updatedBy, String deletedBy) {
        return service.getAllShapes(id, name, description, copiedFromSchemaId, createdBy, updatedBy, deletedBy)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<Shape>>>>() {
                @Override
                public Observable<ServiceResponse<List<Shape>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<Shape>> clientResponse = getAllShapesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<Shape>> getAllShapesDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<List<Shape>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<Shape>>() { }.getType())
                .build(response);
    }

    /**
     * Create shape.
     *
     * @param input the Shape value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object createShape(Shape input) {
        return createShapeWithServiceResponseAsync(input).toBlocking().single().body();
    }

    /**
     * Create shape.
     *
     * @param input the Shape value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> createShapeAsync(Shape input, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(createShapeWithServiceResponseAsync(input), serviceCallback);
    }

    /**
     * Create shape.
     *
     * @param input the Shape value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> createShapeAsync(Shape input) {
        return createShapeWithServiceResponseAsync(input).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Create shape.
     *
     * @param input the Shape value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> createShapeWithServiceResponseAsync(Shape input) {
        if (input == null) {
            throw new IllegalArgumentException("Parameter input is required and cannot be null.");
        }
        Validator.validate(input);
        return service.createShape(input)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = createShapeDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> createShapeDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(201, new TypeToken<Shape>() { }.getType())
                .register(400, new TypeToken<Map<String, List<String>>>() { }.getType())
                .build(response);
    }

    /**
     * Get one shape.
     *
     * @param id the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Shape object if successful.
     */
    public Shape getOneShape(String id) {
        return getOneShapeWithServiceResponseAsync(id).toBlocking().single().body();
    }

    /**
     * Get one shape.
     *
     * @param id the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Shape> getOneShapeAsync(String id, final ServiceCallback<Shape> serviceCallback) {
        return ServiceFuture.fromResponse(getOneShapeWithServiceResponseAsync(id), serviceCallback);
    }

    /**
     * Get one shape.
     *
     * @param id the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Shape object
     */
    public Observable<Shape> getOneShapeAsync(String id) {
        return getOneShapeWithServiceResponseAsync(id).map(new Func1<ServiceResponse<Shape>, Shape>() {
            @Override
            public Shape call(ServiceResponse<Shape> response) {
                return response.body();
            }
        });
    }

    /**
     * Get one shape.
     *
     * @param id the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Shape object
     */
    public Observable<ServiceResponse<Shape>> getOneShapeWithServiceResponseAsync(String id) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        final Integer version = null;
        return service.getOneShape(id, version)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Shape>>>() {
                @Override
                public Observable<ServiceResponse<Shape>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Shape> clientResponse = getOneShapeDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get one shape.
     *
     * @param id the String value
     * @param version the Integer value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Shape object if successful.
     */
    public Shape getOneShape(String id, Integer version) {
        return getOneShapeWithServiceResponseAsync(id, version).toBlocking().single().body();
    }

    /**
     * Get one shape.
     *
     * @param id the String value
     * @param version the Integer value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Shape> getOneShapeAsync(String id, Integer version, final ServiceCallback<Shape> serviceCallback) {
        return ServiceFuture.fromResponse(getOneShapeWithServiceResponseAsync(id, version), serviceCallback);
    }

    /**
     * Get one shape.
     *
     * @param id the String value
     * @param version the Integer value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Shape object
     */
    public Observable<Shape> getOneShapeAsync(String id, Integer version) {
        return getOneShapeWithServiceResponseAsync(id, version).map(new Func1<ServiceResponse<Shape>, Shape>() {
            @Override
            public Shape call(ServiceResponse<Shape> response) {
                return response.body();
            }
        });
    }

    /**
     * Get one shape.
     *
     * @param id the String value
     * @param version the Integer value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Shape object
     */
    public Observable<ServiceResponse<Shape>> getOneShapeWithServiceResponseAsync(String id, Integer version) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        return service.getOneShape(id, version)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Shape>>>() {
                @Override
                public Observable<ServiceResponse<Shape>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Shape> clientResponse = getOneShapeDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Shape> getOneShapeDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Shape, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Shape>() { }.getType())
                .build(response);
    }

    /**
     * Update shape.
     *
     * @param id the String value
     * @param model the Shape value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object updateShape(String id, Shape model) {
        return updateShapeWithServiceResponseAsync(id, model).toBlocking().single().body();
    }

    /**
     * Update shape.
     *
     * @param id the String value
     * @param model the Shape value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> updateShapeAsync(String id, Shape model, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(updateShapeWithServiceResponseAsync(id, model), serviceCallback);
    }

    /**
     * Update shape.
     *
     * @param id the String value
     * @param model the Shape value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> updateShapeAsync(String id, Shape model) {
        return updateShapeWithServiceResponseAsync(id, model).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Update shape.
     *
     * @param id the String value
     * @param model the Shape value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> updateShapeWithServiceResponseAsync(String id, Shape model) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (model == null) {
            throw new IllegalArgumentException("Parameter model is required and cannot be null.");
        }
        Validator.validate(model);
        return service.updateShape(id, model)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = updateShapeDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> updateShapeDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(202, new TypeToken<Shape>() { }.getType())
                .register(400, new TypeToken<Map<String, List<String>>>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .register(409, new TypeToken<Shape>() { }.getType())
                .build(response);
    }

    /**
     * Delete shape.
     *
     * @param id the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteShape(String id) {
        deleteShapeWithServiceResponseAsync(id).toBlocking().single().body();
    }

    /**
     * Delete shape.
     *
     * @param id the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteShapeAsync(String id, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteShapeWithServiceResponseAsync(id), serviceCallback);
    }

    /**
     * Delete shape.
     *
     * @param id the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteShapeAsync(String id) {
        return deleteShapeWithServiceResponseAsync(id).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete shape.
     *
     * @param id the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteShapeWithServiceResponseAsync(String id) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        return service.deleteShape(id)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteShapeDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteShapeDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Get shape versions.
     *
     * @param id the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;Shape&gt; object if successful.
     */
    public List<Shape> getShapeVersions(String id) {
        return getShapeVersionsWithServiceResponseAsync(id).toBlocking().single().body();
    }

    /**
     * Get shape versions.
     *
     * @param id the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<Shape>> getShapeVersionsAsync(String id, final ServiceCallback<List<Shape>> serviceCallback) {
        return ServiceFuture.fromResponse(getShapeVersionsWithServiceResponseAsync(id), serviceCallback);
    }

    /**
     * Get shape versions.
     *
     * @param id the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Shape&gt; object
     */
    public Observable<List<Shape>> getShapeVersionsAsync(String id) {
        return getShapeVersionsWithServiceResponseAsync(id).map(new Func1<ServiceResponse<List<Shape>>, List<Shape>>() {
            @Override
            public List<Shape> call(ServiceResponse<List<Shape>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get shape versions.
     *
     * @param id the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Shape&gt; object
     */
    public Observable<ServiceResponse<List<Shape>>> getShapeVersionsWithServiceResponseAsync(String id) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        return service.getShapeVersions(id)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<Shape>>>>() {
                @Override
                public Observable<ServiceResponse<List<Shape>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<Shape>> clientResponse = getShapeVersionsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<Shape>> getShapeVersionsDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<List<Shape>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<Shape>>() { }.getType())
                .build(response);
    }

}
